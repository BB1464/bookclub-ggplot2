[["index.html", "ggplot2 Book Club Welcome", " ggplot2 Book Club The R4DS Online Learning Community 2022-01-13 Welcome This is a companion for the book ggplot2: Elegant Graphics for Data Analysis by Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen. This companion is available at https://r4ds.github.io/bookclub-ggplot2. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} {Cohort 1 of this club did not create slides for the introduction chapter.} "],["slide-1-title.html", "1.1 {Slide 1 title}", " 1.1 {Slide 1 title} {Create slides as sections, but keep them short like a slide.} "],["meeting-videos.html", "1.2 Meeting Videos", " 1.2 Meeting Videos 1.2.1 Cohort 1 Meeting chat log "],["first-steps.html", "Chapter 2 First Steps ", " Chapter 2 First Steps "],["general-housekeeping-items.html", "2.1 General Housekeeping Items", " 2.1 General Housekeeping Items This is a learning opportunity so feel free to ask any question at any time. Take time to learn the theory, in particular Grammar of Graphics. Please do the chapter exercises. Second-best learning opportunity! Please plan to facilitate one of the discussions. Best learning opportunity! "],["learning-objectives.html", "2.2 Learning Objectives", " 2.2 Learning Objectives Brief introduction to ggplot’s capabilities Learn about key components of every plot: data, aesthetics, geoms Learn about faceting See a few different geoms Modify the axes Save the plot to disk "],["main-data-set.html", "2.3 Main data set", " 2.3 Main data set For this chapter, we’ll mainly use the mpg dataset that comes with ggplot. mpg ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows cty and hwy are miles per gallon measures displ is engine displacement in litres drv is front wheel (f), rear wheel (r) or four wheel (4) model is the model of the car class is two-seater, SUV, compact, etc. "],["components-of-every-plot.html", "2.4 Components of every plot", " 2.4 Components of every plot Three components ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() It’s allowable to omit the x = and y = arguments of aes. In other words, aes(displ, hwy) would be valid for this plot. "],["a-few-exercises.html", "2.5 A few exercises", " 2.5 A few exercises What does the below plot show? Is it useful? How could it improve? ggplot(mpg, aes(model, manufacturer)) + geom_point() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) - Practice coding the following plots. Anticipate what the output will look like. Become familiar with the common components of the plots. ggplot(mpg, aes(cty, hwy)) + geom_point() ggplot(diamonds, aes(carat, price)) + geom_point() ggplot(economics, aes(date, unemploy)) + geom_line() ggplot(mpg, aes(cty)) + geom_histogram() "],["other-aesthetic-attributes.html", "2.6 Other aesthetic attributes", " 2.6 Other aesthetic attributes color, shape and size can be mapped to variables in the data The class variable of the mpg dataset has seven unique values. The plot can assign a specific color to each value by mapping class to color within the aesthetic function. ## # A tibble: 7 × 1 ## class ## &lt;chr&gt; ## 1 compact ## 2 midsize ## 3 suv ## 4 2seater ## 5 minivan ## 6 pickup ## 7 subcompact ggplot(mpg, aes(displ, hwy, color = class)) + geom_point() Including a color assignment outside the aesthetic of the geometry layer will make all of the points that color. ggplot(mpg, aes(displ, hwy)) + geom_point(color = &quot;blue&quot;) Mapping a variable to shape and color adds some diversity and information to the plot. ggplot(mpg, aes(displ, hwy, shape = drv, color = drv)) + geom_point() Mapping a variable to size can also add some new insights. ggplot(mpg, aes(manufacturer, drv, size = displ)) + geom_point() + theme(axis.text.x = element_text(angle = 90)) "],["faceting.html", "2.7 Faceting", " 2.7 Faceting Faceting creates graphics by splitting the data into subsets and displaying the same graph for each subset. Really helpful if there are lots of values, making color/shape less meaningful. ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(~class) Exercise: Use faceting to explore the three-way relationship between fuel economy, engine size and number of cylinders. How does faceting by number of cylinders change your assessment of the relationship between engine size and fuel economy? NOT FACETED BY cyl ggplot(mpg, aes(displ, hwy)) + geom_point() FACETED BY cyl ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(~cyl) "],["geoms.html", "2.8 Geoms", " 2.8 Geoms The geom_point() geom gives a familiar scatterplot. Other geoms include: geom_smooth() which fits a smooth line to the data check help to see geom_smooth’s arguments like method, se or span. ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth() geom_boxplot() which generates a box-and-whisker plot check help to see geom_boxplot’s arguments like outlier arguments, and coef which adjusts the whisker length. ggplot(mpg, aes(drv, hwy)) + geom_boxplot() consider boxplot variants like geom_jitter and geom_violin ggplot(mpg, aes(drv, hwy)) + geom_jitter() ggplot(mpg, aes(drv, hwy)) + geom_violin() geom_histogram which generates a histogram and geom_freqpoly which generates a frequency polygon check help to see geom_histogram’s arguments like position and binwidth. ggplot(mpg, aes(hwy)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(hwy)) + geom_freqpoly() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. geom_bar which generates a bar chart check help to see geom_bar’s arguments like position and width ggplot(mpg, aes(manufacturer)) + geom_bar() We’ll take a second here to talk about the stat argument. Note that in the first bar chart, the y-axis shows the number of observations labeled as count. mpg %&gt;% group_by(manufacturer) %&gt;% count() ## # A tibble: 15 × 2 ## # Groups: manufacturer [15] ## manufacturer n ## &lt;chr&gt; &lt;int&gt; ## 1 audi 18 ## 2 chevrolet 19 ## 3 dodge 37 ## 4 ford 25 ## 5 honda 9 ## 6 hyundai 14 ## 7 jeep 8 ## 8 land rover 4 ## 9 lincoln 3 ## 10 mercury 4 ## 11 nissan 13 ## 12 pontiac 5 ## 13 subaru 14 ## 14 toyota 34 ## 15 volkswagen 27 What if you wanted to sum a certain value for each manufacturer, then you have to tell ggplot “don’t just return the number of observations, add up the values in this certain column”. You do this using the stat argument and by specifying a new variable for the y-axis. For instance, we might be interested in knowing the total price of all vehicles in the data set for each manufacturer. It may be interesting to see if four Land Rovers are more expensive than 14 Hyundais. (No disrepect to Hyundai drivers… I am one myself!) Unfortunately, price isn’t a variable in this dataset so, let’s use displ instead. The sum of displ isn’t particularly meaningful in real life, but it illustrates the use of the stat argument. This graph below uses displ for y in the aesthetic and uses the stat of identity so that it sums the total displacement for each manufacturer. ggplot(mpg, aes(manufacturer, displ)) + geom_bar(stat = &quot;identity&quot;) This plot now shows the total displacement. mpg %&gt;% group_by(manufacturer) %&gt;% summarize(sum(displ)) ## # A tibble: 15 × 2 ## manufacturer `sum(displ)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 45.8 ## 2 chevrolet 96.2 ## 3 dodge 162 ## 4 ford 113. ## 5 honda 15.4 ## 6 hyundai 34 ## 7 jeep 36.6 ## 8 land rover 17.2 ## 9 lincoln 16.2 ## 10 mercury 17.6 ## 11 nissan 42.5 ## 12 pontiac 19.8 ## 13 subaru 34.4 ## 14 toyota 100. ## 15 volkswagen 60.9 geom_line and geom_path which generates a line chart or path chart (useful for time series data) check help to see geom_line’s arguments like lineend and arrow ggplot(economics, aes(date, unemploy / pop)) + geom_line() ggplot(economics, aes(date, uempmed)) + geom_line() To investigate these plots further, we can draw them on the same plot. year &lt;- function(x) as.POSIXlt(x)$year + 1900 ggplot(economics, aes(unemploy / pop, uempmed)) + geom_path(color = &quot;grey50&quot;) + geom_point(aes(color = year(date))) "],["modifying-the-axes.html", "2.9 Modifying the Axes", " 2.9 Modifying the Axes xlab() and ylab() modify the axis labels ggplot(mpg, aes(cty, hwy)) + geom_point(alpha = 1/3) ggplot(mpg, aes(cty, hwy)) + geom_point(alpha = 1/3) + xlab(&quot;city driving (mpg)&quot;) + ylab(&quot;highway driving (mpg)&quot;) # remove labels with NULL ggplot(mpg, aes(cty, hwy)) + geom_point(alpha = 1/3) + xlab(NULL) + ylab(NULL) xlim() and ylim() modify the limits of the axes (boundaries) ggplot(mpg, aes(drv, hwy)) + geom_jitter(width = 0.25) ggplot(mpg, aes(drv, hwy)) + geom_jitter(width = 0.25) + xlim(&quot;f&quot;, &quot;r&quot;) + ylim(20, 30) ## Warning: Removed 139 rows containing missing values (geom_point). "],["output.html", "2.10 Output", " 2.10 Output Save the plot to a variable p &lt;- ggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() Then print it print(p) Save it to disk ggsave(&quot;plot.png&quot;, p, width = 5, height = 5) Describe its structure summary(p) ## data: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl, ## class [234x11] ## mapping: x = ~displ, y = ~hwy, colour = ~factor(cyl) ## faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## compute_layout: function ## draw_back: function ## draw_front: function ## draw_labels: function ## draw_panels: function ## finish_data: function ## init_scales: function ## map_data: function ## params: list ## setup_data: function ## setup_params: function ## shrink: TRUE ## train_scales: function ## vars: function ## super: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## ----------------------------------- ## geom_point: na.rm = FALSE ## stat_identity: na.rm = FALSE ## position_identity "],["layers.html", "Layers", " Layers Introduction Based on the Grammar of Graphics, GGplot2 encourages you to build plots in a structured manner building upon on your plots with various layers. The purposes of the layers are: to display the data. to display a statistical summary of the data. to add metadata such as context, annotations or references to your plot. "],["layers-chapters.html", "2.11 Layers: Chapters", " 2.11 Layers: Chapters The section on layers is broken up into the following chapters: Chapter 3. Individual Geoms Chapter 4. Collective Geoms Chapter 5. Statistical Summaries Chapter 6. Maps Chapter 7. Networks Chapter 8. Annotations Chapter 9. Arranging Plots "],["individual-geoms.html", "Chapter 3 Individual Geoms", " Chapter 3 Individual Geoms Geoms are the fundamental building blocks of ggplot2. Most of the geoms are associated with a named plot. Some geoms can be added on to low-level geoms to create more complex plots. To find out more about individual geoms see their documentation. "],["scatterplot.html", "3.1 Scatterplot:", " 3.1 Scatterplot: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() "],["line-plot.html", "3.2 Line plot:", " 3.2 Line plot: ggplot(economics, aes(date, unemploy / pop)) + geom_line() "],["histogram.html", "3.3 Histogram:", " 3.3 Histogram: ggplot(mpg, aes(hwy)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. "],["bar-chart.html", "3.4 Bar chart", " 3.4 Bar chart ggplot(mpg, aes(manufacturer)) + geom_bar() ## geom_path() connects points in order of appearance. p + geom_path() "],["geom_polygon-draws-polygons-which-are-filled-paths..html", "3.5 geom_polygon() draws polygons which are filled paths.", " 3.5 geom_polygon() draws polygons which are filled paths. p + geom_polygon() "],["geom_line-connects-points-from-left-to-right..html", "3.6 geom_line() connects points from left to right.", " 3.6 geom_line() connects points from left to right. p + geom_line() "],["what-low-level-geoms-are-used-to-draw-geom_smooth.html", "3.7 What low-level geoms are used to draw geom_smooth()?", " 3.7 What low-level geoms are used to draw geom_smooth()? Geom_smooth() fits a smoother to data, displaying the smooth and its standard error, allowing you to see a dominant pattern within a scatterplot with a lot of “noise”. The low level geom for geom_smooth() are geom_path(), geom_area() and geom_point(). ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; "],["what-low-level-geoms-are-used-to-draw-geom_boxplot.html", "3.8 What low-level geoms are used to draw geom_boxplot()?", " 3.8 What low-level geoms are used to draw geom_boxplot()? Box plots are used to summarize the distribution of a set of points using summary statistics. The low level geom for geom_boxplot() are geom_rect(), geom_line() and geom_point(). ggplot(mpg, aes(drv, hwy)) + geom_boxplot() "],["what-low-level-geoms-are-used-to-draw-geom_violin.html", "3.9 What low-level geoms are used to draw geom_violin()?", " 3.9 What low-level geoms are used to draw geom_violin()? Violin plots show a compact representation of the density of the distribution highlighting the areas where most of the points are found. The low level geom for geom_violin() are geom_area() and geom_path(). ggplot(mpg, aes(drv, hwy)) + geom_violin() "],["collective-geoms.html", "Chapter 4 Collective Geoms ", " Chapter 4 Collective Geoms "],["general-housekeeping-items-1.html", "4.1 General Housekeeping Items", " 4.1 General Housekeeping Items This is a learning opportunity so feel free to ask any question at any time. Take time to learn the theory, in particular Grammar of Graphics. Please do the chapter exercises. Second-best learning opportunity! Please plan to facilitate one of the discussions. Best learning opportunity! "],["learning-objectives-1.html", "4.2 Learning Objectives", " 4.2 Learning Objectives Understand the difference between individual geoms and collective geoms Explore some plots that use individual and collective geoms together Reinforce understand of the Grammar of Graphics (particularly the use of layers) to create plots "],["quick-intuition-on-collective-geoms.html", "4.3 Quick Intuition on Collective Geoms", " 4.3 Quick Intuition on Collective Geoms Last chapter was on individual geoms. This chapter is on collective geoms. Oversimplification (but maybe useful) individual numbers vs the sum of the numbers sum converts a series of numbers (“individual”): 4, 7, 9, 3, 3 to a single number (“collective”): 26 home prices under individual geoms each home price has a point on a plot/table under collective geoms we may use median as a single number that summarizes all individuals This blog post by Simon Jackson illustrates these foundations using mtcars. The points are individual geoms and the bars are a collective geom showing the average of the individual observations. id &lt;- mtcars %&gt;% tibble::rownames_to_column() %&gt;% as_tibble() %&gt;% mutate(am = factor(am, levels = c(0, 1), labels = c(&quot;automatic&quot;, &quot;manual&quot;))) gd &lt;- id %&gt;% group_by(am) %&gt;% summarise(hp = mean(hp)) ggplot(id, aes(x = am, y = hp, color = am, fill = am)) + geom_bar(data = gd, stat = &quot;identity&quot;, alpha = 0.3) + ggrepel::geom_text_repel(aes(label = rowname), color = &quot;black&quot;, size = 2.5, segment.color = &quot;grey&quot;) + geom_point() + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_bw() + labs( title = &quot;Car horespower by transmission type&quot;, x = &quot;Transmission&quot;, y = &quot;Horsepower&quot; ) Next, a separate longitudinal study from the blog post (because the book example is also a longitudinal study). This example uses the ourworldindata dataset which shows healthcare spending per country over time. #library(devtools) #install_github(&quot;drsimonj/ourworldindata&quot;) library(ourworldindata) id &lt;- financing_healthcare %&gt;% filter(continent %in% c(&quot;Oceania&quot;, &quot;Europe&quot;) &amp; between(year, 2001, 2005)) %&gt;% select(continent, country, year, health_exp_total) %&gt;% na.omit() raw data id ## # A tibble: 275 × 4 ## continent country year health_exp_total ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Europe Albania 2001 198. ## 2 Europe Albania 2002 225. ## 3 Europe Albania 2003 236. ## 4 Europe Albania 2004 264. ## 5 Europe Albania 2005 277. ## 6 Europe Andorra 2001 1432. ## 7 Europe Andorra 2002 1565. ## 8 Europe Andorra 2003 1601. ## 9 Europe Andorra 2004 1662. ## 10 Europe Andorra 2005 1794. ## # … with 265 more rows individual observations are at the combined country-year level. For the purposes of plotting, though, the “individual geom” will just be the country and all of the yearly observations for each country. gd &lt;- id %&gt;% group_by(continent, year) %&gt;% summarise(health_exp_total = mean(health_exp_total)) ggplot(id, aes(x = year, y = health_exp_total, color = continent)) + geom_line(aes(group = country), alpha = 0.3) + geom_line(data = gd, alpha = 0.8, size = 3) + theme_bw() + labs( title = &quot;Changes in healthcare spending\\nacross countries and world regions&quot;, x = NULL, y = &quot;Total healthcare investment ($)&quot;, color = NULL ) "],["from-the-ggplot2-book.html", "4.4 From the ggplot2 book", " 4.4 From the ggplot2 book dataset called Oxboys which shows the age and corresponding height of 26 boys from Oxford. also a longitudinal study. note that the age is standardized. data(Oxboys, package = &quot;nlme&quot;) head(Oxboys, 9) ## Grouped Data: height ~ age | Subject ## Subject age height Occasion ## 1 1 -1.0000 140.5 1 ## 2 1 -0.7479 143.4 2 ## 3 1 -0.4630 144.8 3 ## 4 1 -0.1643 147.1 4 ## 5 1 -0.0027 147.7 5 ## 6 1 0.2466 150.2 6 ## 7 1 0.5562 151.7 7 ## 8 1 0.7781 153.3 8 ## 9 1 0.9945 155.8 9 4.4.1 Multiple Groups, One Aesthetic As the book says: In many situations, you want to separate your data into groups, but render them in the same way. In other words, you want to be able to distinguish individual subjects but not identify them. sometimes you want the individual geom to be a group of observations for the same individual. you do this by adding a group argument to the aesthetic. If you’re trying to figure out which variable to use as the grouping variable, fill in the blank “I have multiple observations for each _____”. Or for longitudinal studies, “I want to plot one line over time for each _____”. What’s the grouping variable for Oxboys? In the case of Oxboys, we want to plot a line over time for each boy, so Subject is the grouping variable in the aesthetic. ggplot(Oxboys, aes(age, height, group = Subject)) + geom_point() + geom_line() incorrectly specifying the grouping variable leads to a “characteristic sawtooth appearance”. ggplot(Oxboys, aes(age, height)) + geom_point() + geom_line() 4.4.2 Different Groups on Different Layers From the book: Sometimes we want to plot summaries that use different levels of aggregation: one layer might display individuals, while another displays an overall summary. now that we have plotted individual geoms, let’s add a collective geom which is the trendline for all boys together. ggplot(Oxboys, aes(age, height, group = Subject)) + geom_line() + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; something doesn’t look right expecting a collective geom (one summary line for all subjects), but we got individual geoms again – a trendline for each individual instead of a trendline for all individuals. “grouping controls both the display of the geoms, and the operation of the stats: one statistical transformation is run for each group”. we got multiple geom_smooths because we had the grouping variable in the ggplot line so the grouping flows down to all layers of the plot to get what we intend, we need to uncouple the grouping variable at the ggplot layer and add it where we want the grouping to happen, namely only at the geom_line layer. That allows the default grouping from the ggplot layer (i.e., no special grouping or just group on the whole dataset) to flow down to the geom_smooth layer. ggplot(Oxboys, aes(age, height)) + geom_line(aes(group = Subject)) + geom_point() + geom_smooth(method = &quot;lm&quot;, size = 2, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; 4.4.3 Overriding the Default Grouping In the last exercise, we finally got the grouping right. This hints at the approach of overriding the default grouping. By adding the grouping to geom_line, we overrode the default grouping, which was “no special grouping”. Here’s another example to help illustrate this point a little better. Thanks to this blog post. Subtitles are added to these plots to describe what’s going on. ggplot(mpg, aes(drv, hwy)) + geom_jitter() + stat_boxplot(fill = NA) + labs(subtitle = &quot;stat_boxplot automatically uses the groups set by the categorical variable drv.\\nNotice that there is only one boxplot for each value of drv.&quot;) ggplot(mpg, aes(drv, hwy, color = factor(year))) + geom_jitter() + stat_boxplot(fill = NA) + labs(subtitle = &quot;by now adding color based on year, it creates a new group for the boxplots as well,\\nand there are now two for each categorical. This may not be what you want.&quot;) ggplot(mpg, aes(drv, hwy, color = factor(year))) + geom_jitter() + stat_boxplot(fill = NA, aes(group = drv)) + labs(subtitle = &quot;we override the default or earlier grouping by adding\\na group -- inside the aes -- on the layer where we want it&quot;) 4.4.4 A couple of exercises mpg %&gt;% head(2) ## # A tibble: 2 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… #Draw a boxplot of hwy for each value of cyl, without turning cyl into a factor. What extra aesthetic do you need to set? # Wrong... but cyl is an integer data type -- are integers considered continuous? ggplot(mpg, aes(cyl, hwy)) + geom_boxplot() ## Warning: Continuous x aesthetic -- did you forget aes(group=...)? # Right ggplot(mpg, aes(cyl, hwy, group = as.factor(cyl))) + geom_boxplot() #Modify the following plot so that you get one boxplot per integer value of displ. ggplot(mpg, aes(displ, cty)) + geom_boxplot() ## Warning: Continuous x aesthetic -- did you forget aes(group=...)? # probably better ways to do this, especially ways to make the boxplot line up with the x-axis ggplot(mpg, aes(x = ceiling(displ), cty, group = ceiling(displ))) + geom_boxplot() 4.4.5 Matching Aesthetics to Graphic Objects (Not covered in the preso) "],["statistical-summaries.html", "Chapter 5 Statistical Summaries", " Chapter 5 Statistical Summaries Learning Objectives: Use ggplot2 to plot possible uncertainty in your data Determine which geometric object (geom) best presents your type of data "],["defintions-in-this-chapter.html", "5.1 Defintions (in this Chapter)", " 5.1 Defintions (in this Chapter) discrete value: a finite number, something that is countable with beginning and end (input user definition welcomed) continuous value: infinite number, something that never ends. Infinity is continous. (input user definition welcomed) grobs: graphical object overplotting: too much data on scatterplot making underlying relationships obscure "],["revealing-uncertainty.html", "5.2 Revealing Uncertainty", " 5.2 Revealing Uncertainty Four primary types of geometric objects (geom) are used: 1. Discrete x, range: geom_errorbar(), geom_linerange() 2. Discrete x, range &amp; center: geom_crossbar(), geom_pointrange() 3. Continuous x, range: geom_ribbon() 4. Continuous x, range &amp; center: geom_smooth(stat = \"identity\") y &lt;- c(18, 11, 16) df &lt;- data.frame(x = 1:3, y = y, se = c(1.2, 0.5, 1.0)) base &lt;- ggplot(df, aes(x, y, ymin = y - se, ymax = y + se)) base + geom_crossbar() base + geom_pointrange() base + geom_smooth(stat = &quot;identity&quot;) df ## x y se ## 1 1 18 1.2 ## 2 2 11 0.5 ## 3 3 16 1.0 base + geom_errorbar() base + geom_linerange() base + geom_ribbon() "],["weighted-data.html", "5.3 Weighted Data", " 5.3 Weighted Data If each row of your dataframe contains multiple observations, we can use a weight to visually give scale to observations # Unweighted ggplot(midwest, aes(percwhite, percbelowpoverty)) + geom_point() # Weight by population ggplot(midwest, aes(percwhite, percbelowpoverty)) + geom_point(aes(size = poptotal / 1e6)) + scale_size_area(&quot;Population\\n(millions)&quot;, breaks = c(0.5, 1, 2, 4)) # Unweighted ggplot(midwest, aes(percwhite, percbelowpoverty)) + geom_point() + geom_smooth(method = lm, size = 1) ## `geom_smooth()` using formula &#39;y ~ x&#39; # Weighted by population ggplot(midwest, aes(percwhite, percbelowpoverty)) + geom_point(aes(size = poptotal / 1e6)) + geom_smooth(aes(weight = poptotal), method = lm, size = 1) + scale_size_area(guide = &quot;none&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ggplot(midwest, aes(percbelowpoverty)) + geom_histogram(binwidth = 1) + ylab(&quot;Counties&quot;) ggplot(midwest, aes(percbelowpoverty)) + geom_histogram(aes(weight = poptotal), binwidth = 1) + ylab(&quot;Population (1000s)&quot;) Question for the group: Is the above ylab correct? Check out the next two figures, can you see the difference? ggplot(midwest, aes(percbelowpoverty)) + geom_histogram(aes(weight = poptotal/1e3), binwidth = 1) + ylab(&quot;Population (1000s)&quot;) ggplot(midwest, aes(percbelowpoverty)) + geom_histogram(aes(weight = poptotal/1e6), binwidth = 1) + ylab(&quot;Population (millions)&quot;) "],["displaying-distributions.html", "5.4 Displaying distributions", " 5.4 Displaying distributions Using built-in diamonds dataset Figure 5.1: Diamond Dimensions For 1-Dimensional continuous data (1d), the histogram is arguably the most important geom ggplot(diamonds, aes(depth)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(diamonds, aes(depth)) + geom_histogram(binwidth = 0.1) + xlim(55, 70) ## Warning: Removed 45 rows containing non-finite values (stat_bin). ## Warning: Removed 2 rows containing missing values (geom_bar). Never rely on the defaults. Always adjust your bin or xlim to “zoom” in our out of your data. There is no hard or fast rule, only experimentation to discover coorelation in your plot. For your audience/reader, ensure you add a caption for your scale, for example binwidth. Three ways to compare distribution: - Show small multiples of the histogram, facet_wrap(~ var). - Use colour and a frequency polygon, geom_freqpoly(). - Use a “conditional density plot”, geom_histogram(position = \"fill\"). ggplot(diamonds, aes(depth)) + geom_freqpoly(aes(colour = cut), binwidth = 0.1, na.rm = TRUE) + xlim(58, 68) + theme(legend.position = &quot;none&quot;) ggplot(diamonds, aes(depth)) + geom_histogram(aes(fill = cut), binwidth = 0.1, position = &quot;fill&quot;, na.rm = TRUE) + xlim(58, 68) + theme(legend.position = &quot;none&quot;) You can also plot density using geom_density(). Use a density plot when you know that the underlying density is smooth, continuous and unbounded. ggplot(diamonds, aes(depth)) + geom_density(na.rm = TRUE) + xlim(58, 68) + theme(legend.position = &quot;none&quot;) ggplot(diamonds, aes(depth, fill = cut, colour = cut)) + geom_density(alpha = 0.2, na.rm = TRUE) + xlim(58, 68) + theme(legend.position = &quot;none&quot;) It is often the case and advisable to sacrifice quality for quantity. The following three types of graph provide examples of this thought. geom_boxplot(): ggplot(diamonds, aes(clarity, depth)) + geom_boxplot() ggplot(diamonds, aes(carat, depth)) + geom_boxplot(aes(group = cut_width(carat, 0.1))) + xlim(NA, 2.05) ## Warning: Removed 997 rows containing missing values (stat_boxplot). geom_violin(): ggplot(diamonds, aes(clarity, depth)) + geom_violin() ggplot(diamonds, aes(carat, depth)) + geom_violin(aes(group = cut_width(carat, 0.1))) + xlim(NA, 2.05) ## Warning: Removed 997 rows containing non-finite values (stat_ydensity). geom_dotplot(): 5.4.1 Exercise: What binwidth tells you the most interesting story about the distribution of carat? &gt;The number of bins or the binwidth should be exploration exercise. There is not direct hard or fast rule for scaling the binwidth. What is important is to find the appropriate size that best captures the representation (or distribution) of your analysis. This correlates to your story as you are explaining the importance. Find a binwidth that best captures your ideas. Draw a histogram of price. What interesting patterns do you see? ggplot(diamonds, aes(price)) + geom_histogram(binwidth = 5) The smaller the quantity (assuming quality), the higher the price. I presume that carat size would also have a strong correlation with quantity and price. How does the distribution of price vary with clarity? ggplot(diamonds, aes(clarity, price)) + geom_violin() ggplot(diamonds, aes(clarity, price)) + geom_boxplot() I presume using different geoms, the higher the clarity, the higher the price, the fewer the quantity. Overlay a frequency polygon and density plot of depth. What computed variable do you need to map to y to make the two plots comparable? (You can either modify geom_freqpoly() or geom_density().) Not completed. "],["dealing-with-overplotting.html", "5.5 Dealing with overplotting", " 5.5 Dealing with overplotting Scatterplot is a very important tool for assessing relationship Too large a dataset may obscure any true relationship This is called Over plotting To compensate for Over plotting, tweaking the aesthetic can help. Techniques like hollow glyphs can help. df &lt;- data.frame(x = rnorm(2000), y = rnorm(2000)) norm &lt;- ggplot(df, aes(x, y)) + xlab(NULL) + ylab(NULL) norm + geom_point() norm + geom_point(shape = 1) # Hollow circles norm + geom_point(shape = 96) # Pixel sized Alternative ways using large data sets, you can use alpha blending (transparency). If you specify alpha as a ratio, the denominator gives the number of points that must be over plotted to give a solid color. norm + geom_point(alpha = 1 / 3) norm + geom_point(alpha = 1 / 5) norm + geom_point(alpha = 1 / 10) geom_jitter() can be used if your data has some discreteness. By default, 40% is used. You can overide the default with width and height arguments. Alternatively, we can think of overplotting as a 2d density estimation problem, which gives rise to two more approaches: Bin the points and count the number in each bin, then visualise that count (the 2d generalisation of the histogram), geom_bin2d(). The code below compares square and hexagonal bins, using parameters bins and binwidth to control the number and size of the bins. norm + geom_bin2d() norm + geom_bin2d(bins = 10) library(hexbin) norm + geom_hex() norm + geom_hex(bins = 10) Another approach to dealing with overplotting is to add data summaries to help guide the eye to the true shape of the pattern within the data. "],["statistical-summaries-1.html", "5.6 Statistical Summaries", " 5.6 Statistical Summaries geom_histogram() and geom_bin2d() use a familiar geom, geom_bar() and geom_raster(), combined with a new statistical transformation, stat_bin() and stat_bin2d(). stat_bin() and stat_bin2d() combine the data into bins and count the number of observations in each bin. But what if we want a summary other than count? So far, we’ve just used the default statistical transformation associated with each geom. Now we’re going to explore how to use stat_summary_bin() to stat_summary_2d() to compute different summaries. ggplot(diamonds, aes(color)) + geom_bar() ggplot(diamonds, aes(color, price)) + geom_bar(stat = &quot;summary_bin&quot;, fun = mean) ggplot(diamonds, aes(table, depth)) + geom_bin2d(binwidth = 1, na.rm = TRUE) + xlim(50, 70) + ylim(50, 70) ggplot(diamonds, aes(table, depth, z = price)) + geom_raster(binwidth = 1, stat = &quot;summary_2d&quot;, fun = mean, na.rm = TRUE) + xlim(50, 70) + ylim(50, 70) ## Warning: Raster pixels are placed at uneven horizontal intervals and will be ## shifted. Consider using geom_tile() instead. ## Warning: Raster pixels are placed at uneven vertical intervals and will be ## shifted. Consider using geom_tile() instead. So far we’ve considered two classes of geoms: Simple geoms where there’s a one-on-one correspondence between rows in the data frame and physical elements of the geom Statistical geoms where introduce a layer of statistical summaries in between the raw data and the result Although ggplot2 does not have direct 3d support, it does provide the ability to plot 2d images representing 3d data. These include: contours, colored tiles, and bubble plots. ggplot(faithfuld, aes(eruptions, waiting)) + geom_contour(aes(z = density, colour = ..level..)) ggplot(faithfuld, aes(eruptions, waiting)) + geom_raster(aes(fill = density)) # Bubble plots work better with fewer observations small &lt;- faithfuld[seq(1, nrow(faithfuld), by = 10), ] ggplot(small, aes(eruptions, waiting)) + geom_point(aes(size = density), alpha = 1/3) + scale_size_area() "],["maps.html", "Chapter 6 Maps", " Chapter 6 Maps Learning Objectives: - Plot simple maps using geom_polygon() - Using simple features sf to plot GIS data geom_sf() - Work with map projections and underlying sf data structure - Draw maps using Raster data Plotting geospacial data is a common visualization task. The process may require spcialized tools. You can decompse the problem into two paths: - Using one data source to draw a map (if you have GIS data) - Adding metadata from another information source to the map (more common with relation to geographic areas) NOTE: X = Longitude, Y=Latitude. When pronounced “Lat/Lon” it is actually measured as Y/X. Not confusing….just keeping with vocabulary and measurements! "],["polygon-maps.html", "6.1 Polygon Maps", " 6.1 Polygon Maps The simplest approach to mapping is using geom_polygon(). This forms bounderies around regions. library(ggplot2) mi_counties &lt;- map_data(&quot;county&quot;, &quot;michigan&quot;) %&gt;% select(lon = long, lat, group, id = subregion) head(mi_counties) ## lon lat group id ## 1 -83.88675 44.85686 1 alcona ## 2 -83.36536 44.86832 1 alcona ## 3 -83.36536 44.86832 1 alcona ## 4 -83.33098 44.83968 1 alcona ## 5 -83.30806 44.80530 1 alcona ## 6 -83.30233 44.77665 1 alcona In this data set we have four variables: - lat: Latitude of the vertex (as measured by horizontal paths) - long: Longitude of the vertex (as measured by vertical paths) - id: name of the region - group: unique identifier for contiguous areas within a region ggplot(mi_counties, aes(lon, lat)) + geom_point(size = .25, show.legend = FALSE) + coord_quickmap() ggplot(mi_counties, aes(lon, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, colour = &quot;grey50&quot;) + coord_quickmap() In this plot, coord_quickmap() is used to adjust the axes to ensure longitude and latitude are rendered on the same scale For a more advanced use of ggplot2 for mapping, we’ll see the use of geom_sf() and coord_sf() to handle spatial data specified in simple features format. "],["simple-features-maps.html", "6.2 Simple Features Maps", " 6.2 Simple Features Maps You can use the above examples…but not real world pratical. Instead, most GIS data is written as simple features and produced by the (Open Geospatial Consortium]https://www.ogc.org/) 6.2.1 Layered Maps 6.2.2 Labelled Maps 6.2.3 Adding Other Geoms "],["map-projections.html", "6.3 Map Projections", " 6.3 Map Projections "],["working-with-sf-data.html", "6.4 Working with sf Data", " 6.4 Working with sf Data "],["raster-maps.html", "6.5 Raster Maps", " 6.5 Raster Maps "],["data-sources.html", "6.6 Data Sources", " 6.6 Data Sources "],["networks.html", "Chapter 7 Networks", " Chapter 7 Networks Learning Objectives What is Network data? New functions and geoms Visualization of nodes and edges as abstract concepts "],["introduction-1.html", "7.1 Introduction", " 7.1 Introduction This chapter illustrates how to make a Network of data, and how to make practical examples using some of the available packages: {tidygraph} for Tidy API for Graph Manipulation {ggraph} for network visualization {igraph} for generating random and regular graphs "],["what-is-network-data.html", "7.2 What is network data?", " 7.2 What is network data? Networks data consists of entities (nodes or vertices) and their relation (edges or links). Edges can be: directed or undirected 7.2.1 A tidy network manipulation API The first package is tidygraph() a dplyr API for network data. New functions: activate() informs tidygraph on which part of the network you want to work on, either nodes or edges. .N() which gives access to the node data of the current graph even when working with the edges - .E() and .G() to access the edges or the whole graph) In this example we create a graph, assign a random label to the nodes, and sort the edges based on the label of their source node. The function play_erdos_renyi() creates graphs directly through sampling of different attributes. library(tidygraph) graph &lt;- tidygraph::play_erdos_renyi(n = 10, p = 0.2) %&gt;% activate(nodes) %&gt;% mutate(class = sample(letters[1:4], n(), replace = TRUE)) %&gt;% activate(edges) %&gt;% arrange(.N()$class[from]) graph ## # A tbl_graph: 10 nodes and 18 edges ## # ## # A directed simple graph with 1 component ## # ## # Edge Data: 18 × 2 (active) ## from to ## &lt;int&gt; &lt;int&gt; ## 1 2 1 ## 2 3 1 ## 3 2 5 ## 4 2 8 ## 5 6 9 ## 6 5 3 ## # … with 12 more rows ## # ## # Node Data: 10 × 1 ## class ## &lt;chr&gt; ## 1 d ## 2 a ## 3 a ## # … with 7 more rows 7.2.2 Conversion Data can be converted with as_tbl_graph(), a data structure for tidy graph manipulation. It converts a data frame encoded as an edgelist, as well as converting the result of hclust() data(highschool, package = &quot;ggraph&quot;) head(highschool) ## from to year ## 1 1 14 1957 ## 2 1 15 1957 ## 3 1 21 1957 ## 4 1 54 1957 ## 5 1 55 1957 ## 6 2 21 1957 With as_tbl_graph() we obtain: hs_graph &lt;- tidygraph::as_tbl_graph(highschool, directed = FALSE) hs_graph ## # A tbl_graph: 70 nodes and 506 edges ## # ## # An undirected multigraph with 1 component ## # ## # Node Data: 70 × 1 (active) ## name ## &lt;chr&gt; ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 ## # … with 64 more rows ## # ## # Edge Data: 506 × 3 ## from to year ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 13 1957 ## 2 1 14 1957 ## 3 1 20 1957 ## # … with 503 more rows 7.2.2.1 hclust() and dist() functions: In this example the luv_colours() function allows for all built-in colors() translated into Luv colour space, a data frame with 657 observations and 4 variables: luv_colours luv_colours &lt;- as.data.frame(convertColor(t(col2rgb(colors())), &quot;sRGB&quot;, &quot;Luv&quot;)) luv_colours$col &lt;- colors() head(luv_colours) ## L u v col ## 1 9341.570 -3.370649e-12 0.0000 white ## 2 9100.962 -4.749170e+02 -635.3502 aliceblue ## 3 8809.518 1.008865e+03 1668.0042 antiquewhite ## 4 8935.225 1.065698e+03 1674.5948 antiquewhite1 ## 5 8452.499 1.014911e+03 1609.5923 antiquewhite2 ## 6 7498.378 9.029892e+02 1401.7026 antiquewhite3 This visualization represent the content of the dataset, then we will see how it looks in a grapg representation. ggplot(luv_colours, aes(u, v)) + geom_point(aes(colour = col), size = 3) + scale_color_identity() + coord_equal() + theme_void() For example, selecting the first 3 variables and plotting the data with the plot() function we can see that there are some connections within the elements of the dataset, as the colors are connected to each other. ggplot2::luv_colours[, 1:3] %&gt;% head ## L u v ## 1 9341.570 -3.370649e-12 0.0000 ## 2 9100.962 -4.749170e+02 -635.3502 ## 3 8809.518 1.008865e+03 1668.0042 ## 4 8935.225 1.065698e+03 1674.5948 ## 5 8452.499 1.014911e+03 1609.5923 ## 6 7498.378 9.029892e+02 1401.7026 plot(ggplot2::luv_colours[, 1:3]) luv_clust &lt;- hclust(dist(ggplot2::luv_colours[, 1:3])) class(luv_clust) ## [1] &quot;hclust&quot; With the tidygraph::as_tbl_graph() function we can transorm the dataset into classes “tbl_graph”, “igraph” to make it ready to use for making a visualization of the network data. luv_graph &lt;- as_tbl_graph(luv_clust) luv_graph;class(luv_graph) ## # A tbl_graph: 1313 nodes and 1312 edges ## # ## # A rooted tree ## # ## # Node Data: 1,313 × 4 (active) ## height leaf label members ## &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;int&gt; ## 1 0 TRUE &quot;101&quot; 1 ## 2 0 TRUE &quot;427&quot; 1 ## 3 778. FALSE &quot;&quot; 2 ## 4 0 TRUE &quot;571&quot; 1 ## 5 0 TRUE &quot;426&quot; 1 ## 6 0 TRUE &quot;424&quot; 1 ## # … with 1,307 more rows ## # ## # Edge Data: 1,312 × 2 ## from to ## &lt;int&gt; &lt;int&gt; ## 1 3 1 ## 2 3 2 ## 3 8 6 ## # … with 1,309 more rows ## [1] &quot;tbl_graph&quot; &quot;igraph&quot; 7.2.3 Algorithms The real benefit of networks comes from the different operations that can be performed on them using the underlying structure. luv_graph %&gt;% tidygraph::activate(nodes) %&gt;% mutate(centrality = centrality_pagerank()) %&gt;% arrange(desc(centrality)) ## # A tbl_graph: 1313 nodes and 1312 edges ## # ## # A rooted tree ## # ## # Node Data: 1,313 × 5 (active) ## height leaf label members centrality ## &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0 TRUE 207 1 0.000763 ## 2 0 TRUE 315 1 0.000763 ## 3 0 TRUE 208 1 0.000763 ## 4 0 TRUE 316 1 0.000763 ## 5 0 TRUE 205 1 0.000763 ## 6 0 TRUE 313 1 0.000763 ## # … with 1,307 more rows ## # ## # Edge Data: 1,312 × 2 ## from to ## &lt;int&gt; &lt;int&gt; ## 1 1187 1079 ## 2 1187 1080 ## 3 942 797 ## # … with 1,309 more rows "],["visualizing-networks.html", "7.3 Visualizing networks", " 7.3 Visualizing networks To visualize the Network data we use {ggraph}. It builds on top of {tidygraph} and {ggplot2} to allow a complete and familiar grammar of graphics for network data. 7.3.1 Setting up the visualization Syntax of {ggraph}: ggraph() %&gt;% ggraph::geom_&lt;functions&gt; it will choose an appropriate layout based on the type of graph you provide. Getting Started guide to layouts 7.3.1.1 Specifying a layout What is the base requirenment? The data frame need to be with at least an x and y column and with the same number of rows as there are nodes in the input graph. As an example we take the data(highschool, package = \"ggraph\") and make a visualization of the graph: hs_graph &lt;- tidygraph::as_tbl_graph(highschool, directed = FALSE) library(ggraph) ggraph(hs_graph) + geom_edge_link() + geom_node_point() A second example is with more features: hs_graph &lt;- hs_graph %&gt;% tidygraph::activate(edges) %&gt;% mutate(edge_weights = runif(n())) ggraph(hs_graph, layout = &quot;stress&quot;, weights = edge_weights) + geom_edge_link(aes(alpha = edge_weights)) + geom_node_point() + scale_edge_alpha_identity() In the following examples we see different layouts. Information about “drl” type of layout: DRL force-directed graph layout, an be found in the igraph package. layout &lt;- ggraph::create_layout(hs_graph, layout = &#39;drl&#39;) ggraph(layout) + geom_edge_link() + geom_node_point() Instead of {tidygraph} we use {igraph}, with layout = “kk”: layout.kamada.kawai require(ggraph) require(igraph) hs_graph2 &lt;- igraph::graph_from_data_frame(highschool) layout &lt;- create_layout(hs_graph2, layout = &quot;kk&quot;) ggraph(layout) + geom_edge_link(aes(colour = factor(year))) + geom_node_point() A very simple example to understand how to make a graph network is from this tutorial: Networks in igraph To understand a bit more about the graph structure we can use these functions: g1 &lt;- igraph::graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F ) E(g1); # access to the edges ## + 3/3 edges from 82433dd: ## [1] 1--2 2--3 1--3 V(g1); # the vertics ## + 3/3 vertices, from 82433dd: ## [1] 1 2 3 g1[] # access to the matrix ## 3 x 3 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . 1 1 ## [2,] 1 . 1 ## [3,] 1 1 . 7.3.1.2 Circularity Layouts can be linear and circular. coord_polar() changes the coordinate system and not affect the edges ggraph(luv_graph, layout = &#39;dendrogram&#39;, circular = TRUE) + geom_edge_link() + coord_fixed() ggraph(luv_graph, layout = &#39;dendrogram&#39;) + geom_edge_link() + coord_polar() + scale_y_reverse() 7.3.2 Drawing nodes points more specialized geoms: tiles geom_node_&lt;functions&gt; geom_node_point() geom_node_tile() Getting Started guide to nodes ggraph(luv_graph, layout = &quot;stress&quot;) + geom_edge_link() + geom_node_point(aes(colour =factor(members)), show.legend = F) More features could be added to calculate node and edge centrality, such as: centrality_power() centrality_degree() ggraph(luv_graph, layout = &quot;stress&quot;) + geom_edge_link() + geom_node_point(aes(colour =centrality_power())) Or making tiles: ggraph(luv_graph, layout = &quot;treemap&quot;) + geom_node_tile(aes(fill = depth)) 7.3.3 Drawing edges geom_edge_link() draws a straight line between the connected nodes, actually what it does is: it will split up the line in a bunch of small fragments. geom_edge_link() geom_edge_link2() geom_edge_fan() geom_edge_parallel() geom_edge_elbow() geom_edge_bend() geom_edge_diagonal() Getting Started guide to edges The after_stat(index): set.seed(123) ggraph(hs_graph, layout = &quot;stress&quot;) + geom_edge_link(aes(alpha = after_stat(index))) Here is an example about how to use node.class variable, the graph is the first that we have seen and it is artificially made with: tidygraph::play_erdos_renyi() graph &lt;- tidygraph::play_erdos_renyi(n = 10, p = 0.2) %&gt;% activate(nodes) %&gt;% mutate(class = sample(letters[1:4], n(), replace = TRUE)) %&gt;% activate(edges) %&gt;% arrange(.N()$class[from]) ggraph(graph, layout = &quot;stress&quot;) + geom_edge_link2( aes(colour = node.class), width = 3, lineend = &quot;round&quot;) ggraph(hs_graph, layout = &quot;stress&quot;) + geom_edge_parallel() Trees and specifically dendrograms: ggraph(luv_graph, layout = &quot;dendrogram&quot;, height = height) + geom_edge_elbow() 7.3.3.1 Clipping edges around the nodes Example: using arrows to show directionality of edges set.seed(1011) ggraph(graph, layout = &quot;stress&quot;) + geom_edge_link( arrow = arrow(), start_cap = circle(5, &quot;mm&quot;), end_cap = circle(5, &quot;mm&quot;) ) + geom_node_point(aes(colour = class), size = 8) 7.3.3.2 An edge is not always a line Nodes and edges are abstract concepts and can be visualized in a multitude of ways. geom_edge_point() ggraph(hs_graph, layout = &quot;matrix&quot;, sort.by = node_rank_traveller()) + geom_edge_point() 7.3.4 Faceting facet_nodes() facet_edges() facet_graph() ggraph(hs_graph, layout = &quot;stress&quot;) + geom_edge_link() + geom_node_point() + facet_edges(~year) "],["conclusions.html", "7.4 Conclusions", " 7.4 Conclusions Making a {ggraph} means understanding of the different classes of datasets that can be used inside the function. Also, very important is to have clear in mind the structure of the graph that you would like to acheive for representing your data. There are many layouts available, and they differ by the class of provided data. In addition, to do not forget that you can make a network of data using {ggplot2} as well. 7.4.1 Resources: tidygraph website Data Imaginist Imaginist layouts Network analysis with r R and igraph Getting Started guide to layouts Getting Started guide to nodes Getting Started guide to edges "],["placeholder.html", "Chapter 8 PLACEHOLDER", " Chapter 8 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-1.html", "8.1 {Slide 1 title}", " 8.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-1.html", "8.2 Meeting Videos", " 8.2 Meeting Videos 8.2.1 Cohort 1 Meeting chat log "],["arranging-plots.html", "Chapter 9 Arranging Plots", " Chapter 9 Arranging Plots Learning Objectives Produce several subplots part of the same main visualization A range of packages for providing different approaches to arranging separate plots "],["introduction-2.html", "9.1 Introduction", " 9.1 Introduction This chapter focuses on making more than one plot in one visualization, using the following packages: patchwork cowplot gridExtra ggpubr "],["arranging-plots-side-by-side-with-no-overlap.html", "9.2 Arranging plots side by side with no overlap", " 9.2 Arranging plots side by side with no overlap library(patchwork) p1 + p2 # same as p3 | p4 p1 + p2 + p3 + p4 9.2.1 Taking control of the layout p1 + p2 + p3 + plot_layout(ncol = 2) p1 / p2 More compositions: p3 | (p2 / (p1 | p4)) 9.2.2 More about layouts layout &lt;- &quot; AAB C#B CDD &quot; p1 + p2 + p3 + p4 + plot_layout(design = layout) p1 + p2 + p3 + guide_area() + plot_layout(ncol = 2, guides = &quot;collect&quot;) This way is possible a custom modification of the theme for one plot or for both. p12 &lt;- p1 + p2 p12[[1]] &lt;- p12[[1]] + theme_light() p12 p1 + p4 &amp; scale_y_continuous(limits = c(0, 45)) &amp; theme_minimal() 9.2.3 Plot annotations p34 &lt;- p3 + p4 + plot_annotation( title = &quot;A closer look at the effect of drive train in cars&quot;, caption = &quot;Source: mpg dataset in ggplot2&quot;, tag_levels = &quot;I&quot;) &amp; theme_gray(base_family = &quot;mono&quot;) p34 p34[[2]] &lt;- p34[[2]] + plot_layout(tag_level = &quot;new&quot;) p34 + plot_annotation(tag_levels = c(&quot;I&quot;, &quot;a&quot;)) "],["arranging-plots-on-top-of-each-other.html", "9.3 Arranging plots on top of each other", " 9.3 Arranging plots on top of each other It is possible to arrange plots in a way that they are nested to each other, as well as setting the position inside the main plot. General options are left, right, top, and bottom locations, but more specific locations can be set, such as using: grid::unit() (default uses npc units which goes from 0 to 1) In addition, the location is by default set to the panel area, but can be align_to` plot area. An inset can be placed exactly 15 mm from the top right corner. p1 + inset_element( p2, left = 0.4, bottom = 0.4, right = unit(1, &quot;npc&quot;) - unit(15, &quot;mm&quot;), top = unit(1, &quot;npc&quot;) - unit(15, &quot;mm&quot;), align_to = &quot;full&quot; ) p24 &lt;- p2 / p4 + plot_layout(guides = &quot;collect&quot;) p1 + inset_element(p24, left = 0.5, bottom = 0.05, right = 0.95, top = 0.9) + plot_annotation(tag_levels = &#39;A&#39;) &amp; theme_bw() "],["extra.html", "9.4 Extra", " 9.4 Extra grid and gridExtra packages library(gridExtra) library(grid) grid.arrange(p1, p2, p3, p4, ncol=2) cowplot package library(cowplot) plot_grid(p1, p2, labels = c(&#39;A&#39;, &#39;B&#39;), align = &quot;h&quot;, label_size = 12, label_fontfamily = &quot;serif&quot;, label_fontface = &quot;plain&quot;, label_colour = &quot;blue&quot;, rel_widths = c(1, 2)) # We saved this to the images folder already. # ggsave(&quot;images/p1.png&quot;, p1) ggdraw()+ draw_plot(p3)+ draw_image(&quot;images/p1.png&quot;,x=0.4,y=0.4,scale=0.5)+ draw_label(&quot;This is some text&quot;,x=0.5,y=0.9) To add a common title we use `ggdraw() plot_row &lt;- plot_grid(p1, p2) # now add the title title &lt;- ggdraw() + draw_label(&quot;Common title&quot;, fontface = &#39;bold&#39;, x = 0, hjust = 0) + theme(plot.margin = margin(0, 0, 0, 7)) plot_grid(title, plot_row, ncol = 1, rel_heights = c(0.1, 1)) ggdraw()+ draw_plot(p1,x=0.1,y=0,scale=0.5)+ draw_plot(p2,x=-0.2,y=0,scale=0.5)+ draw_label(&quot;This plot is made with cowplot&quot;, x=0.5,y=0.95, color=&quot;pink&quot;, fontface=&quot;bold&quot;,size=20) ggpubr package library(ggpubr) ggarrange(p1, p2, p3, ncol = 2, nrow = 2,common.legend = TRUE) "],["conclusions-1.html", "9.5 Conclusions", " 9.5 Conclusions Patchwork - imaginist is one of the packages mentioned in the book, also some other packages provide same results with different approaches. 9.5.1 Extra resources: grid and gridExtra cowplot ggpubr "],["position-scales-and-axes.html", "Chapter 10 Position scales and axes", " Chapter 10 Position scales and axes Learning Objectives What are the defining components of a scale? When/why does the data need to be transformed for a visualization? What are the defining components of an axis? What is the relationship between scale and axis? library(ggplot2) library(dplyr) library(stringr) # for demo of labels and some other stuff "],["introduction-preliminaries-asides.html", "10.1 Introduction / preliminaries / asides", " 10.1 Introduction / preliminaries / asides This chapter introduces position scales and axes. It may also be helpful to understand position scales and axes as position scales and guides, because axes they share the same API as guides for non-positional scales like color legends. The parallel will be clearer in the next chapter. It’s worthwhile to read documentations of the {scales} package to learn more about scales, since that handles a lot of the (re-)scaling and transformation under the hood. It may be good to start with the rstudio::conf2020 talk on scales. knitr::include_url(&quot;https://www.rstudio.com/resources/rstudioconf-2020/the-little-package-that-could-taking-visualizations-to-the-next-level-with-the-scales-package/&quot;) It should also be noted that there’s some discussion about revamping the scales_* API. See issue #4269 and PR #4271 Lastly, a small aside on the book’s after_stat() example it he intro, continuing nicely from our discussion on ggplot internals last week. # Grab the layer object created by `geom_histogram()` histogram_layer &lt;- geom_histogram() # Check what stat ggproto it uses class(histogram_layer$stat)[1] ## [1] &quot;StatBin&quot; # Confirm that the stat has `after_stat(count)` as the default aes StatBin$default_aes # or, `histogram_layer$stat$default_aes` ## Aesthetic mapping: ## * `x` -&gt; `after_stat(count)` ## * `y` -&gt; `after_stat(count)` ## * `weight` -&gt; 1 # The stat takes an x or y aesthetic, so it does implicitly maps # `after_stat(count)` to the unspecified aes StatBin$required_aes ## [1] &quot;x|y&quot; geom_histogram(aes(x = displ))$mapping ## Aesthetic mapping: ## * `x` -&gt; `displ` # &#39;orientation&#39; argument allows horizontal bars without `coord_flip()` # as of v.3.3.0 (Dec 2020) ggplot(mpg, aes(y = displ)) + geom_histogram(orientation = &quot;y&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. "],["numeric.html", "10.2 10.1 Numeric", " 10.2 10.1 Numeric 10.2.1 10.1.1 Limits The book doesn’t have content for this section (??) But we know that you can set limits with xlim()/ylim() or scale_x|y_*(limits = ) lim_plot &lt;- ggplot(mtcars, aes(x = hp, y = disp)) + geom_point() lim_plot lim_plot + xlim(0, 500) # NA to use range of data lim_plot + xlim(0, NA) # Same thing lim_plot + scale_x_continuous(limits = c(0, NA)) 10.2.2 10.1.2 Out of bounds values NOTE: A big theme of the {scales} package as of v1.1.1 (May 2020) is that they have very transparent function names. For example, the family of functions for Out Of Bounds (oob) handling are all named oob_*(). This is an intentional (re-)design of the package to work nicely with autocomplete. str_subset(ls(envir = asNamespace(&quot;scales&quot;)), &quot;^oob_&quot;) ## [1] &quot;oob_censor&quot; &quot;oob_censor_any&quot; &quot;oob_discard&quot; ## [4] &quot;oob_keep&quot; &quot;oob_squish&quot; &quot;oob_squish_any&quot; ## [7] &quot;oob_squish_infinite&quot; By default, data outside scales are set to NA. This is because the oob argument is set to oob_censor()/censor(). Note that oob only applies to continuous scales, since values of a discrete scale form a fixed set. body(scale_x_continuous) ## { ## sc &lt;- continuous_scale(ggplot_global$x_aes, &quot;position_c&quot;, ## identity, name = name, breaks = breaks, n.breaks = n.breaks, ## minor_breaks = minor_breaks, labels = labels, limits = limits, ## expand = expand, oob = oob, na.value = na.value, trans = trans, ## guide = guide, position = position, super = ScaleContinuousPosition) ## set_sec_axis(sec.axis, sc) ## } formals(continuous_scale)$oob ## censor Book’s examples: base &lt;- ggplot(mpg, aes(drv, hwy)) + geom_hline(yintercept = 28, colour = &quot;red&quot;) + geom_boxplot(alpha = .2) # I set alpha here for a later demo base base + coord_cartesian(ylim = c(10, 35)) base + ylim(10, 35) ## Warning: Removed 6 rows containing non-finite values (stat_boxplot). Equivalent solutions with oob_*() # zoom only (keeps out of bounds values for the stat computation) base + scale_y_continuous(limits = c(10, 35), oob = scales::oob_keep) # default that removes out of bounds values base + scale_y_continuous(limits = c(10, 35), oob = scales::oob_censor) ## Warning: Removed 6 rows containing non-finite values (stat_boxplot). # squish option (plots outliers at the uper limit of y = 35) base + scale_y_continuous(limits = c(10, 35), oob = scales::oob_squish) You can use oob functions for non-positional scales df &lt;- data.frame(x = 1:6, y = 8:13) base &lt;- ggplot(df, aes(x, y)) + geom_col(aes(fill = x)) + # bar chart geom_vline(xintercept = 3.5, colour = &quot;red&quot;) # for visual clarity only base base + scale_fill_gradient(limits = c(1, 3)) # oob = scales::oob_censor base + scale_fill_gradient(limits = c(1, 3), oob = scales::squish) # scales::oob_squish 10.2.3 10.1.3 Visual range expansion Book examples: f_plot &lt;- ggplot(faithfuld, aes(waiting, eruptions)) + geom_raster(aes(fill = density)) + theme(legend.position = &quot;none&quot;) f_plot f_plot + scale_x_continuous(expand = c(0,0)) + # expand = 0 scale_y_continuous(expand = c(0,0)) # expand = 0 With expansion() from v3.3.0 (Dec 2020) formals(expansion) ## $mult ## [1] 0 ## ## $add ## [1] 0 f_plot + scale_y_continuous(expand = expansion(mult = 0)) # mult = c(0, 0) f_plot + scale_y_continuous(expand = expansion(mult = 1)) f_plot + scale_y_continuous(expand = expansion(mult = c(0, 1))) f_plot + scale_y_continuous(expand = expansion(mult = c(0, 1))) + scale_x_continuous(expand = expansion(add = c(0, 10))) 10.2.4 10.1.4 Exercises 10.2.5 10.1.5 Breaks str_subset(ls(envir = asNamespace(&quot;scales&quot;)), &quot;^breaks_&quot;) ## [1] &quot;breaks_extended&quot; &quot;breaks_log&quot; &quot;breaks_pretty&quot; &quot;breaks_width&quot; Book example: toy &lt;- data.frame( const = 1, up = 1:4, txt = letters[1:4], big = (1:4)*1000, log = c(2, 5, 10, 2000) ) toy ## const up txt big log ## 1 1 1 a 1000 2 ## 2 1 2 b 2000 5 ## 3 1 3 c 3000 10 ## 4 1 4 d 4000 2000 #&gt; const up txt big log #&gt; 1 1 1 a 1000 2 #&gt; 2 1 2 b 2000 5 #&gt; 3 1 3 c 3000 10 #&gt; 4 1 4 d 4000 2000 axs &lt;- ggplot(toy, aes(big, const)) + geom_point() + labs(x = NULL, y = NULL) axs axs + scale_x_continuous(breaks = scales::breaks_extended()) axs + scale_x_continuous(breaks = scales::breaks_extended(n = 2)) axs + scale_x_continuous(breaks = NULL) Demo from {scales}: scales::demo_continuous(c(1000, 4000), breaks = scales::breaks_extended()) ## scale_x_continuous(breaks = scales::breaks_extended()) scales::demo_continuous(c(1000, 4000), breaks = scales::breaks_extended(n = 2)) ## scale_x_continuous(breaks = scales::breaks_extended(n = 2)) scales::demo_continuous(c(1000, 4000), NULL) ## scale_x_continuous(NULL) At the vector level: scales::breaks_extended()(c(1000, 4000)) ## [1] 1000 2000 3000 4000 scales::breaks_extended(n = 2)(c(1000, 4000)) ## [1] 1000 4000 Other breaks: my_range &lt;- c(1, 101) scales::breaks_extended()(my_range) ## [1] 0 25 50 75 100 scales::breaks_width(width = 10)(my_range) ## [1] 0 10 20 30 40 50 60 70 80 90 100 110 scales::breaks_pretty(width = 10)(my_range) # pretty(1:101) ## [1] 0 20 40 60 80 100 120 scales::breaks_log()(my_range) ## [1] 1 10 100 1000 Debugging arguments in scale_*() that take function factories browserer &lt;- function(...) { params &lt;- list(...) browser() if (exists(&quot;result&quot;)) { return(result) } } axs + scale_x_continuous(breaks = browserer) 10.2.6 10.1.6 Minor breaks Book example: mb &lt;- unique(as.numeric(1:10 %o% 10 ^ (0:3))) mb ## [1] 1 2 3 4 5 6 7 8 9 10 20 30 ## [13] 40 50 60 70 80 90 100 200 300 400 500 600 ## [25] 700 800 900 1000 2000 3000 4000 5000 6000 7000 8000 9000 ## [37] 10000 log_base &lt;- ggplot(toy, aes(log, const)) + geom_point() log_base + scale_x_log10() log_base + scale_x_log10(minor_breaks = mb) There are also minor break functions: str_subset(ls(envir = asNamespace(&quot;scales&quot;)), &quot;^minor_breaks_&quot;) ## [1] &quot;minor_breaks_n&quot; &quot;minor_breaks_width&quot; 10.2.7 10.1.7 Labels str_subset(ls(envir = asNamespace(&quot;scales&quot;)), &quot;^label_&quot;) ## [1] &quot;label_bytes&quot; &quot;label_comma&quot; &quot;label_date&quot; ## [4] &quot;label_date_short&quot; &quot;label_dollar&quot; &quot;label_math&quot; ## [7] &quot;label_number&quot; &quot;label_number_auto&quot; &quot;label_number_si&quot; ## [10] &quot;label_ordinal&quot; &quot;label_parse&quot; &quot;label_percent&quot; ## [13] &quot;label_pvalue&quot; &quot;label_scientific&quot; &quot;label_time&quot; ## [16] &quot;label_wrap&quot; Book examples: axs + scale_y_continuous(labels = scales::label_percent()) axs + scale_y_continuous(labels = scales::label_dollar(prefix = &quot;&quot;, suffix = &quot;€&quot;)) tibble( x = c(&quot;cat1&quot;, &quot;cat2 with a really really realy long name&quot;, &quot;cat3&quot;), y = 1:3 ) %&gt;% ggplot(aes(x, y)) + geom_col() tibble( x = c(&quot;cat1&quot;, &quot;cat2 with a really really realy long name&quot;, &quot;cat3&quot;), y = 1:3 ) %&gt;% ggplot(aes(x, y)) + geom_col() + scale_x_discrete(labels = scales::label_wrap(width = 30)) 10.2.8 10.1.8 Exercises 10.2.9 10.1.9 Transformations Book example: ggplot(diamonds, aes(price, carat)) + geom_bin2d() # log transform x and y axes ggplot(diamonds, aes(price, carat)) + geom_bin2d() + scale_x_continuous(trans = &quot;log10&quot;) + scale_y_continuous(trans = &quot;log10&quot;) The transformation is carried out by a “transformer”, which describes the transformation, its inverse, and how to draw the labels. You can construct your own transformer using scales::trans_new() Case study: make reversed log x-axis ggplot(starwars, aes(x = mass)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 28 rows containing non-finite values (stat_bin). ggplot(starwars, aes(x = mass)) + geom_histogram() + scale_x_log10() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 28 rows containing non-finite values (stat_bin). ggplot(starwars, aes(x = mass)) + geom_histogram() + scale_x_reverse() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 28 rows containing non-finite values (stat_bin). scale_x_log10()$trans # scales::log10_trans() ## Transformer: log-10 scale_x_reverse()$trans # scales::reverse_trans() ## Transformer: reverse formals(scales::trans_new) ## $name ## ## ## $transform ## ## ## $inverse ## ## ## $breaks ## extended_breaks() ## ## $minor_breaks ## regular_minor_breaks() ## ## $format ## format_format() ## ## $domain ## c(-Inf, Inf) log10_reverse &lt;- scales::trans_new( name = &quot;log-10-reverse&quot;, transform = function(x) -log(x, 10), inverse = function(x) 10^(-x), breaks = scales::log10_trans()$breaks, minor_breaks = scales::log10_trans()$minor_breaks, domain = scales::log10_trans()$domain ) ggplot(starwars, aes(x = mass)) + geom_histogram() + scale_x_continuous(trans = log10_reverse) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 28 rows containing non-finite values (stat_bin). Regardless of which method you use, the transformation occurs before any statistical summaries. To transform after statistical computation use coord_trans() From the docs: ggplot(diamonds, aes(carat, price)) + geom_point() + scale_x_log10() + scale_y_log10() ggplot(diamonds, aes(carat, price)) + geom_point() + coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) Example where stat transformation matters: trans_plot &lt;- ggplot(mpg, aes(drv, hwy)) + geom_boxplot() trans_plot + scale_y_log10() trans_plot + coord_trans(y = &quot;log10&quot;) # scales::log10_trans() layer_data(trans_plot) %&gt;% select(x, starts_with(&quot;y&quot;)) ## x ymin ymax ymin_final ymax_final ## 1 1 12 28 12 28 ## 2 2 22 33 17 44 ## 3 3 15 26 15 26 layer_data(trans_plot + scale_y_log10()) %&gt;% select(x, starts_with(&quot;y&quot;)) ## x ymin ymax ymin_final ymax_final ## 1 1 1.079181 1.447158 1.079181 1.447158 ## 2 2 1.361728 1.531479 1.230449 1.643453 ## 3 3 1.176091 1.414973 1.176091 1.414973 layer_data(trans_plot + coord_trans(y = &quot;log10&quot;)) %&gt;% select(x, starts_with(&quot;y&quot;)) ## x ymin ymax ymin_final ymax_final ## 1 1 12 28 12 28 ## 2 2 22 33 17 44 ## 3 3 15 26 15 26 10.2.10 ASIDE - A little more on transformations transform() method of the Scales ggproto: transform() Transforms a vector of values using self$trans. This occurs before the Stat is calculated. Transformation changes the layer data toy # from Ch 10.1.5 ## const up txt big log ## 1 1 1 a 1000 2 ## 2 1 2 b 2000 5 ## 3 1 3 c 3000 10 ## 4 1 4 d 4000 2000 ggplot(toy, aes(big, txt)) + geom_point() reversed_plot &lt;- ggplot(toy, aes(big, txt)) + geom_point() + scale_x_reverse() reversed_plot layer_data(reversed_plot) ## x y PANEL group shape colour size fill alpha stroke ## 1 -1000 1 1 1 19 black 1.5 NA NA 0.5 ## 2 -2000 2 1 2 19 black 1.5 NA NA 0.5 ## 3 -3000 3 1 3 19 black 1.5 NA NA 0.5 ## 4 -4000 4 1 4 19 black 1.5 NA NA 0.5 rev_trans &lt;- scales::reverse_trans() scales::reverse_trans ## function () ## { ## trans_new(&quot;reverse&quot;, function(x) -x, function(x) -x, minor_breaks = regular_minor_breaks(reverse = TRUE)) ## } ## &lt;bytecode: 0x7fa29e420440&gt; ## &lt;environment: namespace:scales&gt; str(rev_trans) ## List of 7 ## $ name : chr &quot;reverse&quot; ## $ transform :function (x) ## $ inverse :function (x) ## $ breaks :function (x, n = n_default) ## $ minor_breaks:function (b, limits, n) ## $ format :function (x) ## $ domain : num [1:2] -Inf Inf ## - attr(*, &quot;class&quot;)= chr &quot;trans&quot; rev_trans$transform(toy$big) ## [1] -1000 -2000 -3000 -4000 rev_trans$inverse(rev_trans$transform(toy$big)) ## [1] 1000 2000 3000 4000 rev_trans$format(rev_trans$breaks(range(toy$big))) ## [1] &quot;1000&quot; &quot;2000&quot; &quot;3000&quot; &quot;4000&quot; Most useful for positioning purposes (ex: time_trans()) hours &lt;- seq(ISOdate(2000,3,20, tz = &quot;&quot;), by = &quot;hour&quot;, length.out = 10) t &lt;- scales::time_trans() t$transform(hours) ## [1] 953553600 953557200 953560800 953564400 953568000 953571600 953575200 ## [8] 953578800 953582400 953586000 t$inverse(t$transform(hours)) ## [1] &quot;2000-03-20 12:00:00 UTC&quot; &quot;2000-03-20 13:00:00 UTC&quot; ## [3] &quot;2000-03-20 14:00:00 UTC&quot; &quot;2000-03-20 15:00:00 UTC&quot; ## [5] &quot;2000-03-20 16:00:00 UTC&quot; &quot;2000-03-20 17:00:00 UTC&quot; ## [7] &quot;2000-03-20 18:00:00 UTC&quot; &quot;2000-03-20 19:00:00 UTC&quot; ## [9] &quot;2000-03-20 20:00:00 UTC&quot; &quot;2000-03-20 21:00:00 UTC&quot; t$format(t$breaks(range(hours))) ## [1] &quot;12:00&quot; &quot;15:00&quot; &quot;18:00&quot; &quot;21:00&quot; date_trans_plot &lt;- ggplot(tibble(hours = hours), aes(x = hours, y = 0)) + geom_point() layer_data(date_trans_plot) ## x y PANEL group shape colour size fill alpha stroke ## 1 953553600 0 1 -1 19 black 1.5 NA NA 0.5 ## 2 953557200 0 1 -1 19 black 1.5 NA NA 0.5 ## 3 953560800 0 1 -1 19 black 1.5 NA NA 0.5 ## 4 953564400 0 1 -1 19 black 1.5 NA NA 0.5 ## 5 953568000 0 1 -1 19 black 1.5 NA NA 0.5 ## 6 953571600 0 1 -1 19 black 1.5 NA NA 0.5 ## 7 953575200 0 1 -1 19 black 1.5 NA NA 0.5 ## 8 953578800 0 1 -1 19 black 1.5 NA NA 0.5 ## 9 953582400 0 1 -1 19 black 1.5 NA NA 0.5 ## 10 953586000 0 1 -1 19 black 1.5 NA NA 0.5 "],["date-time.html", "10.3 10.2 Date-time", " 10.3 10.2 Date-time 10.3.1 10.2.1 Breaks Book example: date_base &lt;- ggplot(economics, aes(date, psavert)) + geom_line(na.rm = TRUE) + labs(x = NULL, y = NULL) date_base date_base + scale_x_date(date_breaks = &quot;25 years&quot;) Making it explicit: date_base + scale_x_date(breaks = scales::breaks_width(&quot;25 years&quot;)) Book example: century20 &lt;- as.Date(c(&quot;1900-01-01&quot;, &quot;1999-12-31&quot;)) breaks &lt;- scales::breaks_width(&quot;25 years&quot;) breaks(century20) ## [1] &quot;1900-01-01&quot; &quot;1925-01-01&quot; &quot;1950-01-01&quot; &quot;1975-01-01&quot; &quot;2000-01-01&quot; Using offset argument (unit = days): breaks2 &lt;- scales::breaks_width(&quot;25 years&quot;, offset = 31) # offsets to Feb breaks2(century20) ## [1] &quot;1900-02-01&quot; &quot;1925-02-01&quot; &quot;1950-02-01&quot; &quot;1975-02-01&quot; &quot;2000-02-01&quot; Calculating the offset: diff.Date(c(as.Date(&quot;1900-01-01&quot;), as.Date(&quot;1900-02-01&quot;))) # as.integer() to get value ## Time difference of 31 days 10.3.2 10.2.2 Minor breaks Book examples: date_base + scale_x_date( limits = as.Date(c(&quot;2003-01-01&quot;, &quot;2003-04-01&quot;)), date_breaks = &quot;1 month&quot; ) date_base + scale_x_date( limits = as.Date(c(&quot;2003-01-01&quot;, &quot;2003-04-01&quot;)), date_breaks = &quot;1 month&quot;, date_minor_breaks = &quot;1 week&quot; ) In the second plot, the major and minor beaks follow slightly different patterns: the minor breaks are always spaced 7 days apart but the major breaks are 1 month apart. Because the months vary in length, this leads to slightly uneven spacing. Explicit: date_base + scale_x_date( limits = as.Date(c(&quot;2003-01-01&quot;, &quot;2003-04-01&quot;)), breaks = scales::breaks_width(&quot;1 month&quot;) ) date_base + scale_x_date( limits = as.Date(c(&quot;2003-01-01&quot;, &quot;2003-04-01&quot;)), breaks = scales::breaks_width(&quot;1 month&quot;), minor_breaks = scales::breaks_width(&quot;1 week&quot;) ) 10.3.3 10.2.3 Labels Book examples: base &lt;- ggplot(economics, aes(date, psavert)) + geom_line(na.rm = TRUE) + labs(x = NULL, y = NULL) base + scale_x_date(date_breaks = &quot;5 years&quot;) base + scale_x_date(date_breaks = &quot;5 years&quot;, date_labels = &quot;%y&quot;) base + scale_x_date(labels = scales::label_date_short()) lim &lt;- as.Date(c(&quot;2004-01-01&quot;, &quot;2005-01-01&quot;)) base + scale_x_date(limits = lim, labels = scales::label_date_short()) "],["discrete.html", "10.4 10.3 Discrete", " 10.4 10.3 Discrete Book examples: ggplot(mpg, aes(x = hwy, y = class)) + geom_point() ggplot(mpg, aes(x = hwy, y = class)) + geom_point() + scale_x_continuous() + scale_y_discrete() ggplot(mpg, aes(x = hwy, y = class)) + geom_point() + annotate(&quot;text&quot;, x = 5, y = 1:7, label = 1:7) 10.4.1 10.3.1 Limits For discrete scales, limits should be a character vector that enumerates all possible values. Censors missing categories in the set: ggplot(mpg, aes(x = hwy, y = class)) + geom_point() + scale_y_discrete(limits = unique(mpg$class)[-1]) ## Warning: Removed 47 rows containing missing values (geom_point). Adds new categories without value: ggplot(mpg, aes(x = hwy, y = class)) + geom_point() + scale_y_discrete(limits = c(&quot;A&quot;, unique(mpg$class))) Same effect with drop = FALSE with unused factor levels ggplot(mpg, aes(x = hwy, y = factor(class, levels = c(&quot;A&quot;, unique(class))))) + geom_point() + scale_y_discrete(drop = FALSE) It drops unused factor levels by default, though ggplot(mpg, aes(x = hwy, y = factor(class, levels = c(&quot;A&quot;, unique(class))))) + geom_point() # + scale_y_discrete(drop = TRUE) 10.4.2 10.3.2 Scale labels layer_data(last_plot()) %&gt;% ggplot(aes(x = x, y = y, group = group)) + geom_point() 10.4.3 10.3.2 Scale labels Book example: base &lt;- ggplot(toy, aes(const, txt)) + geom_point() + labs(x = NULL, y = NULL) base base + scale_y_discrete(labels = c(c = &quot;carrot&quot;, b = &quot;banana&quot;)) base + scale_y_discrete(labels = str_to_title) Debugging strategy browserer &lt;- function(...) { params &lt;- list(...) browser() } base + scale_y_discrete(labels = browserer) 10.4.4 10.3.3 guide_axis() Book examples: base &lt;- ggplot(mpg, aes(manufacturer, hwy)) + geom_boxplot() base + guides(x = guide_axis(n.dodge = 3)) base + guides(x = guide_axis(angle = 90)) More guides in {ggh4x} - https://teunbrand.github.io/ggh4x/ library(ggh4x) tibble( item = c(&quot;Coffee&quot;, &quot;Tea&quot;, &quot;Apple&quot;, &quot;Pear&quot;, &quot;Car&quot;), type = c(&quot;Drink&quot;, &quot;Drink&quot;, &quot;Fruit&quot;, &quot;Fruit&quot;, &quot;&quot;), amount = c(5, 1, 2, 3, 1) ) %&gt;% ggplot(aes(interaction(item, type), amount)) + geom_col() + scale_x_discrete(guide = guide_axis_nested()) # guides(x = &quot;axis_nested&quot;) "],["binned.html", "10.5 10.4 Binned", " 10.5 10.4 Binned Book example: base &lt;- ggplot(mpg, aes(hwy, class)) + geom_count() base base + scale_x_binned(n.breaks = 10) ggplot(mtcars, aes(hp)) + geom_histogram(binwidth = 20) ggplot(mtcars, aes(hp)) + geom_bar() + scale_x_binned(breaks = scales::breaks_width(width = 20)) ## Warning: Ignoring n.breaks. Use a breaks function that supports setting number ## of breaks "],["aside---geom_sf-limits.html", "10.6 ASIDE - geom_sf() + limits", " 10.6 ASIDE - geom_sf() + limits 10.6.1 Example from Twitter: https://twitter.com/Josh_Ebner/status/1470818469801299970?s=20 10.6.2 Reprexes from Ryan S: library(sf) ## Registered S3 methods overwritten by &#39;proxy&#39;: ## method from ## print.registry_field registry ## print.registry_entry registry ## Linking to GEOS 3.8.1, GDAL 3.2.1, PROJ 7.2.1; sf_use_s2() is TRUE plygn_1 &lt;- tibble(x_coord = c(1, 1, 2, 3, 6, 1), y_coord = c(1, 2, 1, 2, 5, 1)) plygn_1 ## # A tibble: 6 × 2 ## x_coord y_coord ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 1 2 ## 3 2 1 ## 4 3 2 ## 5 6 5 ## 6 1 1 Full range polygon plygn_1 %&gt;% ggplot() + geom_polygon(aes(x_coord, y_coord)) Polygon with limits poly_plygn_1 &lt;- plygn_1 %&gt;% ggplot() + geom_polygon(aes(x_coord, y_coord)) + scale_x_continuous(limits = c(1, 4)) poly_plygn_1 Path with limits path_plygn_1 &lt;- plygn_1 %&gt;% ggplot() + geom_path(aes(x_coord, y_coord)) + scale_x_continuous(limits = c(1, 4)) path_plygn_1 geom_sf() without limits sf_plygn_1 &lt;- plygn_1 %&gt;% # tibble of coords as.matrix() %&gt;% # make into a matrix list() %&gt;% # make into a list st_polygon() %&gt;% # make into sf object ggplot() + # call ggplot geom_sf() # use geom_sf for plotting sf objects sf_plygn_1 geom_sf() with limits sf_plygn_1_wlims &lt;- sf_plygn_1 + scale_x_continuous(limits = c(1, 4)) # add limits sf_plygn_1_wlims 10.6.3 Further exploration Using geom_sf() adds CoordSF by default class(sf_plygn_1$coordinates) ## [1] &quot;CoordSf&quot; &quot;CoordCartesian&quot; &quot;Coord&quot; &quot;ggproto&quot; ## [5] &quot;gg&quot; class(sf_plygn_1_wlims$coordinates) ## [1] &quot;CoordSf&quot; &quot;CoordCartesian&quot; &quot;Coord&quot; &quot;ggproto&quot; ## [5] &quot;gg&quot; In fact, geom_sf() must be used with coord_sf() # Same thing as without limits `sf_plygn_1` sf_plygn_1 + coord_sf() # Same thing as with limits `sf_plygn_1_wlims` sf_plygn_1 + coord_sf(xlim = c(1, 4)) # Doesn&#39;t work sf_plygn_1 + coord_cartesian() ## Error: geom_sf() must be used with coord_sf() The underlying geometry is untouched (indicating that limits are not removing data) layer_data(sf_plygn_1) ## geometry PANEL group xmin xmax ymin ymax linetype alpha ## 1 POLYGON ((1 1, 1 2, 2 1, 3 ... 1 -1 1 6 1 5 1 NA ## stroke ## 1 0.5 layer_data(sf_plygn_1_wlims) ## geometry PANEL group xmin xmax ymin ymax linetype alpha ## 1 POLYGON ((1 1, 1 2, 2 1, 3 ... 1 -1 1 NA 1 5 1 NA ## stroke ## 1 0.5 identical( layer_data(sf_plygn_1_wlims)$geometry, layer_data(sf_plygn_1)$geometry ) ## [1] TRUE OOB handling inside scale_x|y_continuous() cannot override the behavior sf_plygn_1 + scale_x_continuous(limits = c(1, 4), oob = scales::oob_censor) Instead, coord_sf(lims_method = ) offers other spatial-specific methods. Censor doesn’t seem to be one but an option like \"geometry_bbox\" automatically sets limits to the smallest bounding box that contain all geometries. sf_plygn_1 + coord_sf(lims_method = &quot;geometry_bbox&quot;) sf_plygn_1_wlims + coord_sf(lims_method = &quot;geometry_bbox&quot;) Interesting note from the docs: … specifying limits via position scales or xlim()/ylim() is strongly discouraged, as it can result in data points being dropped from the plot even though they would be visible in the final plot region. 10.6.4 Internals library(ggtrace) # v.0.4.5 Scale censor for geom_polygon() ggbody(ggplot2:::ggplot_build.ggplot)[[17]] ggtrace( method = ggplot2:::ggplot_build.ggplot, trace_steps = 17, trace_exprs = quote(browser()), verbose = FALSE ) path_plygn_1 Scale censor for geom_sf() ggtrace( method = ggplot2:::ggplot_build.ggplot, trace_steps = 17, # and 26 `layout$map_position` trace_exprs = quote(browser()), verbose = FALSE ) sf_plygn_1_wlims Inspecting the rendered geom with layer_grob() patchwork::wrap_elements(layer_grob(poly_plygn_1)[[1]]) patchwork::wrap_elements(layer_grob(sf_plygn_1)[[1]]) patchwork::wrap_elements(layer_grob(sf_plygn_1_wlims)[[1]]) dplyr::bind_cols(layer_grob(sf_plygn_1)[[1]][c(&quot;x&quot;, &quot;y&quot;)]) ## # A tibble: 6 × 2 ## x y ## &lt;simplUnt&gt; &lt;simplUnt&gt; ## 1 0.04545455native 0.04545455native ## 2 0.04545455native 0.2727273native ## 3 0.2272727native 0.04545455native ## 4 0.4090909native 0.2727273native ## 5 0.9545455native 0.9545455native ## 6 0.04545455native 0.04545455native dplyr::bind_cols(layer_grob(sf_plygn_1_wlims)[[1]][c(&quot;x&quot;, &quot;y&quot;)]) # x for fifth row is &gt;1npc ## # A tibble: 6 × 2 ## x y ## &lt;simplUnt&gt; &lt;simplUnt&gt; ## 1 0.04545455native 0.04545455native ## 2 0.04545455native 0.2727273native ## 3 0.3484848native 0.04545455native ## 4 0.6515152native 0.2727273native ## 5 1.560606native 0.9545455native ## 6 0.04545455native 0.04545455native "],["colour-scales-and-legends.html", "Chapter 11 Colour Scales and Legends", " Chapter 11 Colour Scales and Legends Learning Objectives -Learn how to map values to colours in ggplot2 -Learn about colour theory (a more detailed exposition is available online at http://tinyurl.com/clrdtls) "],["a-little-colour-theory.html", "11.1 A little colour theory", " 11.1 A little colour theory There have been many attempts to come up with colours spaces that are more perceptually uniform. We’ll use a modern attempt called the HCL colour space, which has three components of hue, chroma and luminance: -Hue ranges from 0 to 360 (an angle) and gives the “colour” of the colour (blue, red, orange, etc). -Chroma is the “purity” of a colour, ranging from 0 (grey) to a maximum that varies with luminance. -Luminance is the lightness of the colour, ranging from 0 (black) to 1 (white). An additional complication is that many people (~10% of men) do not possess the normal complement of colour receptors and so can distinguish fewer colours than usual. In brief, it’s best to avoid red-green contrasts, and to check your plots with systems that simulate colour blindness. Visicheck (https://www.vischeck.com/vischeck/) is one online solution. Another alternative is the dichromat package34 which provides tools for simulating colour blindness, and a set of colour schemes known to work well for colour-blind people. You can also help people with colour blindness in the same way that you can help people with black-and-white printers: by providing redundant mappings to other aesthetics like size, line type or shape. 11.1.1 Colour blindness "],["continuous-colour-scales.html", "11.2 Continuous colour scales", " 11.2 Continuous colour scales Colour gradients are often used to show the height of a 2d surface. The plots in this section use the surface of a 2d density estimate of the faithful dataset which records the waiting time between eruptions and during each eruption for the Old Faithful geyser in Yellowstone Park. Any time I refer to scale_fill_() in this section there is a corresponding scale_colour_() for the colour aesthetic (or scale_color_*() if you prefer US spelling). 11.2.1 Particular pallettes There are multiple ways to specify continuous colour scales. You can use to construct your own palette, but it is unnecessary because there are many “hand picked” palettes available. Ggplot2 supplies two scale functions that bundle pre-specified palettes, scale_fill_viridis_c() and scale_fill_distiller(). The viridis scales are designed to be perceptually uniform in both colour and when reduced to black and white, and to be perceptible to people with various forms of colour blindness. erupt erupt + scale_fill_viridis_c() erupt + scale_fill_viridis_c(option = &quot;magma&quot;) The second group of continuous colour scales built in to ggplot2 are derived from the ColorBrewer scales: scale_fill_brewer() provides these colours as discrete palettes, while scale_fill_distiller() and scale_fill_fermenter() are the continuous and binned analogs. erupt + scale_fill_distiller() erupt + scale_fill_distiller(palette = &quot;RdPu&quot;) erupt + scale_fill_distiller(palette = &quot;YlOrBr&quot;) scale_fill_scico() provides palettes that are perceptually uniform and suitable for scientific visualisation erupt + scico::scale_fill_scico(palette = &quot;bilbao&quot;) # the default erupt + scico::scale_fill_scico(palette = &quot;vik&quot;) erupt + scico::scale_fill_scico(palette = &quot;lajolla&quot;) A particularly useful package is paletteer which aims to provide a common interface. erupt + paletteer::scale_fill_paletteer_c(&quot;viridis::plasma&quot;) erupt + paletteer::scale_fill_paletteer_c(&quot;scico::tokyo&quot;) erupt + paletteer::scale_fill_paletteer_c(&quot;gameofthrones::targaryen&quot;) 11.2.2 Robust recipes The default scale for continuous fill scales is scale_fill_continuous() which in turn defaults to scale_fill_gradient(). As a consequence, these three commands produce the same plot using a gradient scale. erupt erupt + scale_fill_continuous() erupt + scale_fill_gradient() Gradient scales provide a robust method for creating any colour scheme you like. You just specify two or more reference colours, and ggplot2 will interpolate linearly between them. Three functions that you can use for this purpose are *scale_fill_gradient() produces a two-colour gradient *scale_fill_gradient2() produces a three-colour gradient with specified midpoint *scale_fill_gradientn() produces an n-colour gradient erupt + scale_fill_gradient(low = &quot;grey&quot;, high = &quot;brown&quot;) erupt + scale_fill_gradient2(low = &quot;grey&quot;, mid = &quot;white&quot;, high = &quot;brown&quot;, midpoint = .02) erupt + scale_fill_gradientn(colours = terrain.colors(7)) The Munsell colour system provides an easy way of specifying colours based on their hue, chroma and luminance. The munsell package provides easy access to the Munsell colours, which can then be used to specify a gradient scale. For more information on the munsell package see https://github.com/cwickham/munsell/. munsell::hue_slice(&quot;5P&quot;) + # generate a ggplot with hue_slice() annotate( # add arrows for annotation geom = &quot;segment&quot;, x = c(7, 7), y = c(1, 10), xend = c(7, 7), yend = c(2, 9), arrow = arrow(length = unit(2, &quot;mm&quot;)) ) ## Warning: Removed 31 rows containing missing values (geom_text). #&gt; Warning: Removed 31 rows containing missing values (geom_text). # construct scale erupt + scale_fill_gradient( low = munsell::mnsl(&quot;5P 2/12&quot;), high = munsell::mnsl(&quot;5P 7/12&quot;) ) Three-point gradient scales typically convey the perceptual impression that there is a natural midpoint (often a zero value) from which the other values diverge. The left plot below shows how to create a divergent “yellow/blue” scale. If you have colours that are meaningful for your data (e.g., black body colours or standard terrain colours), or you’d like to use a palette produced by another package, you may wish to use an n-point gradient. The middle and right plots below use the colorspace package. For more information on the colorspace package see https://colorspace.r-forge.r-project.org/. # munsell example erupt + scale_fill_gradient2( low = munsell::mnsl(&quot;5B 7/8&quot;), high = munsell::mnsl(&quot;5Y 7/8&quot;), mid = munsell::mnsl(&quot;N 7/0&quot;), midpoint = .02 ) # colorspace examples erupt + scale_fill_gradientn(colours = colorspace::heat_hcl(7)) erupt + scale_fill_gradientn(colours = colorspace::diverge_hcl(7)) 11.2.3 Missing values All continuous colour scales have an na.value parameter that controls what colour is used for missing values (including values outside the range of the scale limits). By default it is set to grey, which will stand out when you use a colourful scale. If you use a black and white scale, you might want to set it to something else to make it more obvious. You can set na.value = NA to make missing values invisible, or choose a specific colour if you prefer: df &lt;- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5)) base &lt;- ggplot(df, aes(x, y)) + geom_tile(aes(fill = z), size = 5) + labs(x = NULL, y = NULL) base base + scale_fill_gradient(na.value = NA) base + scale_fill_gradient(na.value = &quot;yellow&quot;) 11.2.4 Limits, breaks and labels You can suppress the breaks entirely by setting them to NULL. For axes, this removes the tick marks, grid lines, and labels; and for legends this removes the keys and labels. toy &lt;- data.frame( const = 1, up = 1:4, txt = letters[1:4], big = (1:4)*1000, log = c(2, 5, 10, 2000) ) leg &lt;- ggplot(toy, aes(up, up, fill = big)) + geom_tile() + labs(x = NULL, y = NULL) leg + scale_fill_continuous(breaks = NULL) 11.2.5 Legends base &lt;- ggplot(mpg, aes(cyl, displ, colour = hwy)) + geom_point(size = 2) base base + guides(colour = guide_colourbar(reverse = TRUE)) base + guides(colour = guide_colourbar(barheight = unit(2, &quot;cm&quot;))) base + guides(colour = guide_colourbar(direction = &quot;horizontal&quot;)) base + guides(colour = guide_colourbar(reverse = TRUE)) base + scale_colour_continuous(guide = guide_colourbar(reverse = TRUE)) "],["discrete-colour-scales.html", "11.3 Discrete colour scales", " 11.3 Discrete colour scales Discrete colour and fill scales occur in many situations. A typical example is a barchart that encodes both position and fill to the same variable. The default scale for discrete colours is scale_fill_discrete() which in turn defaults to scale_fill_hue() so these are identical plots: bars bars + scale_fill_discrete() bars + scale_fill_hue() 11.3.1 Brewer scales scale_colour_brewer() is a discrete colour scale that—along with the continuous analog scale_colour_distiller() and binned analog scale_colour_fermenter()—uses handpicked “ColorBrewer” colours taken from http://colorbrewer2.org/. These colours have been designed to work well in a wide variety of situations, although the focus is on maps and so the colours tend to work better when displayed in large areas. There are many different options: RColorBrewer::display.brewer.all() The first group of palettes are sequential scales that are useful when your discrete scale is ordered (e.g., rank data), and are available for continuous data using scale_colour_distiller(). For unordered categorical data, the palettes of most interest are those in the second group. ‘Set1’ and ‘Dark2’ are particularly good for points, and ‘Set2’, ‘Pastel1’, ‘Pastel2’ and ‘Accent’ work well for areas. bars + scale_fill_brewer(palette = &quot;Set1&quot;) bars + scale_fill_brewer(palette = &quot;Set2&quot;) bars + scale_fill_brewer(palette = &quot;Accent&quot;) Note that no palette is uniformly good for all purposes. Scatter plots typically use small plot markers, and bright colours tend to work better than subtle ones: # scatter plot df &lt;- data.frame(x = 1:3 + runif(30), y = runif(30), z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) point &lt;- ggplot(df, aes(x, y)) + geom_point(aes(colour = z)) + theme(legend.position = &quot;none&quot;) + labs(x = NULL, y = NULL) # three palettes point + scale_colour_brewer(palette = &quot;Set1&quot;) point + scale_colour_brewer(palette = &quot;Set2&quot;) point + scale_colour_brewer(palette = &quot;Pastel1&quot;) Bar plots usually contain large patches of colour, and bright colours can be overwhelming. Subtle colours tend to work better in this situation: # bar plot df &lt;- data.frame(x = 1:3, y = 3:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) area &lt;- ggplot(df, aes(x, y)) + geom_bar(aes(fill = z), stat = &quot;identity&quot;) + theme(legend.position = &quot;none&quot;) + labs(x = NULL, y = NULL) # three palettes area + scale_fill_brewer(palette = &quot;Set1&quot;) area + scale_fill_brewer(palette = &quot;Set2&quot;) area + scale_fill_brewer(palette = &quot;Pastel1&quot;) 11.3.2 Hue and grey scales The default colour scheme picks evenly spaced hues around the HCL colour wheel. This works well for up to about eight colours, but after that it becomes hard to tell the different colours apart. You can control the default chroma and luminance, and the range of hues, with the h, c and l arguments: bars bars + scale_fill_hue(c = 40) bars + scale_fill_hue(h = c(180, 300)) One disadvantage of the default colour scheme is that because the colours all have the same luminance and chroma, when you print them in black and white, they all appear as an identical shade of grey. Noting this, if you are intending a discrete colour scale to be printed in black and white, it is better to use scale_fill_grey() which maps discrete data to grays, from light to dark: bars + scale_fill_grey() bars + scale_fill_grey(start = 0.5, end = 1) bars + scale_fill_grey(start = 0, end = 0.5) 11.3.3 Paleteer Scales 11.3.4 Manual scales If none of the hand-picked palettes is suitable, or if you have your own preferred colours, you can use scale_fill_manual() to set the colours manually. This can be useful if you wish to choose colours that highlight a secondary grouping structure or draw attention to different comparisons: bars + scale_fill_manual(values = c(&quot;sienna1&quot;, &quot;sienna4&quot;, &quot;hotpink1&quot;, &quot;hotpink4&quot;)) bars + scale_fill_manual(values = c(&quot;tomato1&quot;, &quot;tomato2&quot;, &quot;tomato3&quot;, &quot;tomato4&quot;)) bars + scale_fill_manual(values = c(&quot;grey&quot;, &quot;black&quot;, &quot;grey&quot;, &quot;grey&quot;)) You can also use a named vector to specify colors to be assigned to each level which allows you to specify the levels in any order you like: bars + scale_fill_manual(values = c( &quot;d&quot; = &quot;grey&quot;, &quot;c&quot; = &quot;grey&quot;, &quot;b&quot; = &quot;black&quot;, &quot;a&quot; = &quot;grey&quot; )) 11.3.5 Limits, breaks and labels mpg_99 &lt;- mpg %&gt;% filter(year == 1999) mpg_08 &lt;- mpg %&gt;% filter(year == 2008) base_99 &lt;- ggplot(mpg_99, aes(displ, hwy, colour = fl)) + geom_point() base_08 &lt;- ggplot(mpg_08, aes(displ, hwy, colour = fl)) + geom_point() base_99 base_08 base_99 + lims(colour = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;)) base_08 + lims(colour = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;)) base_99 + lims( x = c(1, 7), y = c(10, 45), colour = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;) ) base_08 + lims( x = c(1, 7), y = c(10, 45), colour = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;) ) base_99 + scale_color_discrete( limits = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;), breaks = c(&quot;d&quot;, &quot;p&quot;, &quot;r&quot;), labels = c(&quot;diesel&quot;, &quot;premium&quot;, &quot;regular&quot;) ) base_99 + lims(x = c(1, 7), y = c(10, 45)) + scale_color_discrete( limits = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;), breaks = c(&quot;d&quot;, &quot;p&quot;, &quot;r&quot;), labels = c(&quot;diesel&quot;, &quot;premium&quot;, &quot;regular&quot;) ) base_08 + lims(x = c(1, 7), y = c(10, 45)) + scale_color_discrete( limits = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;p&quot;, &quot;r&quot;), labels = c(&quot;compressed&quot;, &quot;diesel&quot;, &quot;ethanol&quot;, &quot;premium&quot;, &quot;regular&quot;) ) 11.3.6 Legends base &lt;- ggplot(mpg, aes(drv, fill = factor(cyl))) + geom_bar() base base + guides(fill = guide_legend(ncol = 2)) base + guides(fill = guide_legend(ncol = 2, byrow = TRUE)) base base + guides(fill = guide_legend(reverse = TRUE)) base &lt;- ggplot(mpg, aes(displ, hwy, colour = drv)) + geom_point(size = 4, alpha = .2, stroke = 0) base + guides(colour = guide_legend()) base + guides(colour = guide_legend(override.aes = list(alpha = 1))) "],["binned-colour-scales.html", "11.4 Binned colour scales", " 11.4 Binned colour scales Color scales also come in binned versions. The default scale is scale_fill_binned() which in turn defaults to scale_fill_steps(). These scales have an n.breaks argument that controls the number of discrete colour categories created by the scale. Counterintuitively—because the human visual system is very good at detecting edges—this can sometimes make a continuous colour gradient easier to perceive: erupt + scale_fill_binned() erupt + scale_fill_steps() erupt + scale_fill_steps(n.breaks = 8) In other respects scale_fill_steps() is analogous to scale_fill_gradient(), and allows you to construct your own two-colour gradients. There is also a three-colour variant scale_fill_steps2() and n-colour scale variant scale_fill_stepsn() that behave similarly to their continuous counterparts: erupt + scale_fill_steps(low = &quot;grey&quot;, high = &quot;brown&quot;) erupt + scale_fill_steps2(low = &quot;grey&quot;, mid = &quot;white&quot;, high = &quot;brown&quot;, midpoint = .02) erupt + scale_fill_stepsn(n.breaks = 12, colours = terrain.colors(12)) A brewer analog for binned scales also exists, and is called scale_fill_fermenter(): erupt + scale_fill_fermenter(n.breaks = 9) erupt + scale_fill_fermenter(n.breaks = 9, palette = &quot;Oranges&quot;) erupt + scale_fill_fermenter(n.breaks = 9, palette = &quot;PuOr&quot;) Note that like the discrete scale_fill_brewer()—and unlike the continuous scale_fill_distiller()—the binned function scale_fill_fermenter() does not interpolate between the brewer colours, and if you set n.breaks larger than the number of colours in the palette a warning message will appear and some colours will not be displayed. 11.4.1 Limits, breaks and labels 11.4.2 Legends base &lt;- ggplot(mpg, aes(cyl, displ, colour = hwy)) + geom_point(size = 2) + scale_color_binned() base base + guides(colour = guide_coloursteps(show.limits = TRUE)) "],["date-time-colour-scales.html", "11.5 Date Time Colour Scales", " 11.5 Date Time Colour Scales When a colour aesthetic is mapped to a date/time type, ggplot2 uses scale_colour_date() or scale_colour_datetime() to specify the scale. These are designed to handle date data, analogous to the date scales discussed in Section 10.2. These scales have date_breaks and date_labels arguments that make it a little easier to work with these data, as the slightly contrived example below illustrates: base &lt;- ggplot(economics, aes(psavert, uempmed, colour = date)) + geom_point() base base + scale_colour_date( date_breaks = &quot;142 months&quot;, date_labels = &quot;%b %Y&quot; ) "],["alpha-scales.html", "11.6 Alpha scales", " 11.6 Alpha scales Alpha scales map the transparency of a shade to a value in the data and can be a convenient way to visually down-weight less important observations. scale_alpha() is an alias for scale_alpha_continuous() since that is the most common use of alpha, and it saves a bit of typing. ggplot(faithfuld, aes(waiting, eruptions, alpha = density)) + geom_raster(fill = &quot;maroon&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) "],["legend-position.html", "11.7 Legend position", " 11.7 Legend position A number of settings that affect the overall display of the legends are controlled through the theme system. You’ll learn more about that in Section 18.2, but for now, all you need to know is that you modify theme settings with the theme() function. The position and justification of legends are controlled by the theme setting legend.position, which takes values “right”, “left”, “top”, “bottom”, or “none” (no legend). base &lt;- ggplot(toy, aes(up, up)) + geom_point(aes(colour = txt), size = 3) + xlab(NULL) + ylab(NULL) base + theme(legend.position = &quot;left&quot;) base + theme(legend.position = &quot;right&quot;) # the default base + theme(legend.position = &quot;bottom&quot;) base + theme(legend.position = &quot;none&quot;) Switching between left/right and top/bottom modifies how the keys in each legend are laid out (horizontal or vertically), and how multiple legends are stacked (horizontal or vertically). If needed, you can adjust those options independently: legend.direction: layout of items in legends (“horizontal” or “vertical”). legend.box: arrangement of multiple legends (“horizontal” or “vertical”). legend.box.just: justification of each legend within the overall bounding box, when there are multiple legends (“top”, “bottom”, “left”, or “right”). Alternatively, if there’s a lot of blank space in your plot you might want to place the legend inside the plot by setting legend.position to a numeric vector of length two. The numbers represent a relative location in the panel area: c(0, 1) is the top-left corner and c(1, 0) is the bottom-right corner. You control which corner of the legend the legend.position refers to with legend.justification, which is specified in a similar way. Unfortunately positioning the legend exactly where you want it requires a lot of trial and error. base &lt;- ggplot(toy, aes(up, up)) + geom_point(aes(colour = txt), size = 3) base + theme( legend.position = c(0, 1), legend.justification = c(0, 1) ) base + theme( legend.position = c(0.5, 0.5), legend.justification = c(0.5, 0.5) ) base + theme( legend.position = c(1, 0), legend.justification = c(1, 0) ) "],["other-aesthetics.html", "Chapter 12 Other Aesthetics", " Chapter 12 Other Aesthetics Learning objectives: To learn about several other aesthetics that ggplot2 can use to represent data, including: size scales shape scales line type scales manual scales identity scales "],["size.html", "12.1 Size", " 12.1 Size The size aesthetic is typically used to scale points and text. The default scale for size aesthetics is scale_size() in which a linear increase in the variable is mapped onto a linear increase in the area (not the radius) of the geom. base &lt;- ggplot(mpg, aes(displ, hwy, size = cyl)) + geom_point() base base + scale_size(range = c(1, 2)) There are several size scales: scale_size_area() and scale_size_binned_area() are versions of scale_size() and scale_size_binned() that ensure that a value of 0 maps to an area of 0. scale_radius() maps the data value to the radius rather than to the area (Section 12.1.1). scale_size_binned() is a size scale that behaves like scale_size() but maps continuous values onto discrete size categories, analogous to the binned position and colour scales discussed in Sections 10.4 and 11.4 respectively. Legends associated with this scale are discussed in Section 12.1.2. scale_size_date() and scale_size_datetime() are designed to handle date data, analogous to the date scales discussed in Section 10.2. 12.1.1 Radius size scales There are situations where area scaling is undesirable, and for such situations scale_radius() may be more appropriate. For example, consider a data set containing astronomical data that includes the radius of different planets: ## name type position radius orbit ## 1 Mercury Inner 1 2440 57900000 ## 2 Venus Inner 2 6052 108200000 ## 3 Earth Inner 3 6378 149600000 ## 4 Mars Inner 4 3390 227900000 ## 5 Jupiter Outer 5 71400 778300000 ## 6 Saturn Outer 6 60330 1427000000 ## 7 Uranus Outer 7 25559 2871000000 ## 8 Neptune Outer 8 24764 4497100000 base &lt;- ggplot(planets, aes(1, name, size = radius)) + geom_point() + scale_x_continuous(breaks = NULL) + labs(x = NULL, y = NULL, size = NULL) base + ggtitle(&quot;not to scale&quot;) base + scale_radius(limits = c(0, NA), range = c(0, 10)) + ggtitle(&quot;to scale&quot;) 12.1.2 Binned size scales Binned size scales work similarly to binned scales for colour and position aesthetics (Sections 11.4 and 10.4) with the exception of how legends are displayed. The default legend for a binned size scale, and all binned scales except position and colour aesthetics, is governed by guide_bins(). For instance, in the mpg data we could use scale_size_binned() to create a binned version of the continuous variable hwy: base &lt;- ggplot(mpg, aes(displ, manufacturer, size = hwy)) + geom_point(alpha = .2) + scale_size_binned() base Unlike guide_legend(), the guide created for a binned scale by guide_bins() does not organize the individual keys into a table. Instead they are arranged in a column (or row) along a single vertical (or horizontal) axis, which by default is displayed with its own axis. The important arguments to guide_bins() are listed below: axis indicates whether the axis should be drawn (default is TRUE) base + guides(size = guide_bins(axis = FALSE)) direction is a character string specifying the direction of the guide, either “vertical” (the default) or “horizontal” base + guides(size = guide_bins(direction = &quot;horizontal&quot;)) show.limits specifies whether tick marks are shown at the ends of the guide axis (default is FALSE) base + guides(size = guide_bins(show.limits = TRUE)) axis.colour, axis.linewidth and axis.arrow are used to control the guide axis that is displayed alongside the legend keys base + guides( size = guide_bins( axis.colour = &quot;red&quot;, axis.arrow = arrow( length = unit(.1, &quot;inches&quot;), ends = &quot;first&quot;, type = &quot;closed&quot; ) ) ) keywidth, keyheight, reverse and override.aes have the same behavior for guide_bins() as they do for guide_legend() (see Section 11.3.6) "],["shape.html", "12.2 Shape", " 12.2 Shape Values can be mapped to the shape aesthetic, most typically when you have a small number of discrete categories. Note: if the data variable contains more than 6 values it becomes difficult to distinguish between shapes, and will produce a warning. Although any one plot is unlikely to be readable with more than a 6 distinct markers, there are 25 possible shapes to choose from. The default scale_shape() function contains a single argument: set solid = TRUE (the default) to use a “palette” consisting of three solid shapes and three hollow shapes, or set solid = FALSE to use six hollow shapes: base &lt;- ggplot(mpg, aes(displ, hwy, shape = factor(cyl))) + geom_point() base base + scale_shape(solid = FALSE) You can specify the marker types for each data value manually using scale_shape_manual(). For more information about manual scales see Section 12.4. base + scale_shape_manual( values = c(&quot;4&quot; = 16, &quot;5&quot; = 17, &quot;6&quot; = 1 , &quot;8&quot; = 2) ) "],["line-type.html", "12.3 Line type", " 12.3 Line type It is possible to map a variable onto the linetype aesthetic, which works best for discrete variables with a small number of categories, where scale_linetype() is an alias for scale_linetype_discrete(). Continuous variables cannot be mapped to line types unless scale_linetype_binned() is used: although there is a scale_linetype_continuous() function, all it does is produce an error. ggplot(economics_long, aes(date, value01, linetype = variable)) + geom_line() With five categories the above plot is quite difficult to read. The default “palette” for linetype is supplied by the scales::linetype_pal() function, and includes the 13 linetypes shown below: df &lt;- data.frame(value = letters[1:13]) base &lt;- ggplot(df, aes(linetype = value)) + geom_segment( mapping = aes(x = 0, xend = 1, y = value, yend = value), show.legend = FALSE ) + theme(panel.grid = element_blank()) + scale_x_continuous(NULL, NULL) base You can control the line type by specifying a string with up to 8 hexadecimal values. In this specification, -the first value is the length of the first line segment, the second value is the length of the first space between segments, and so on. This allows you to specify your own line types using scale_linetype_manual(), or alternatively, by passing a custom function to the palette argument. Note that the last four lines are blank, because the linetypes() function defined above returns NA when the number of categories exceeds 9. linetypes &lt;- function(n) { types &lt;- c(&quot;55&quot;, &quot;75&quot;, &quot;95&quot;, &quot;1115&quot;, &quot;111115&quot;, &quot;11111115&quot;, &quot;5158&quot;, &quot;9198&quot;, &quot;c1c8&quot;) return(types[seq_len(n)]) } base + scale_linetype(palette = linetypes) The scale_linetype() function contains a na.value argument used to specify what kind of line is plotted for these values. By default this produces a blank line, but you can override this by setting na.value = “dotted”: base + scale_linetype(palette = linetypes, na.value = &quot;dotted&quot;) Valid line types can be set using a human readable character string: “blank”, “solid”, “dashed”, “dotted”, “dotdash”, “longdash”, and “twodash” are all understood. "],["manual-scales-1.html", "12.4 Manual scales", " 12.4 Manual scales Manual scales are just a list of valid values that are mapped to the unique discrete values. If you want to customize these scales, you need to create your own new scale with the “manual” version of each: scale_linetype_manual(), scale_shape_manual(), scale_colour_manual(), etc. The manual scale has one important argument, values, where you specify the values that the scale should produce if this vector is named, it will match the values of the output to the values of the input; otherwise it will match in order of the levels of the discrete variable. You will need some knowledge of the valid aesthetic values, which are described in vignette(“ggplot2-specs”). Manual scales have appeared earlier, in Sections 11.3.4 and 12.2. In the following example, you’ll see a creative use of scale_colour_manual() to display multiple variables on the same plot and show a useful legend. -In most plotting systems, you’d color the lines and then add a legend: huron &lt;- data.frame(year = 1875:1972, level = as.numeric(LakeHuron)) ggplot(huron, aes(year)) + geom_line(aes(y = level + 5), colour = &quot;red&quot;) + geom_line(aes(y = level - 5), colour = &quot;blue&quot;) That doesn’t work in ggplot because there’s no way to add a legend manually. Instead, give the lines informative labels: ggplot(huron, aes(year)) + geom_line(aes(y = level + 5, colour = &quot;above&quot;)) + geom_line(aes(y = level - 5, colour = &quot;below&quot;)) And then tell the scale how to map labels to colours: ggplot(huron, aes(year)) + geom_line(aes(y = level + 5, colour = &quot;above&quot;)) + geom_line(aes(y = level - 5, colour = &quot;below&quot;)) + scale_colour_manual(&quot;Direction&quot;, values = c(&quot;above&quot; = &quot;red&quot;, &quot;below&quot; = &quot;blue&quot;) ) "],["identity-scales.html", "12.5 Identity Scales", " 12.5 Identity Scales Identity scales — such as scale_colour_identity() and scale_shape_identity() — are used when your data is already scaled such that the data and aesthetic spaces are the same. The code below shows an example where the identity scale is useful. luv_colours contains the locations of all R’s built-in colours in the LUV colour space (the space that HCL is based on). head(luv_colours) ## L u v col ## 1 9341.570 -3.370649e-12 0.0000 white ## 2 9100.962 -4.749170e+02 -635.3502 aliceblue ## 3 8809.518 1.008865e+03 1668.0042 antiquewhite ## 4 8935.225 1.065698e+03 1674.5948 antiquewhite1 ## 5 8452.499 1.014911e+03 1609.5923 antiquewhite2 ## 6 7498.378 9.029892e+02 1401.7026 antiquewhite3 #&gt; L u v col #&gt; 1 9342 -3.37e-12 0 white #&gt; 2 9101 -4.75e+02 -635 aliceblue #&gt; 3 8810 1.01e+03 1668 antiquewhite #&gt; 4 8935 1.07e+03 1675 antiquewhite1 #&gt; 5 8452 1.01e+03 1610 antiquewhite2 #&gt; 6 7498 9.03e+02 1402 antiquewhite3 ggplot(luv_colours, aes(u, v)) + geom_point(aes(colour = col), size = 3) + scale_color_identity() + coord_equal() "],["placeholder-1.html", "Chapter 13 PLACEHOLDER", " Chapter 13 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-2.html", "13.1 {Slide 1 title}", " 13.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-2.html", "13.2 Meeting Videos", " 13.2 Meeting Videos 13.2.1 Cohort 1 Meeting chat log "],["placeholder-2.html", "Chapter 14 PLACEHOLDER", " Chapter 14 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-3.html", "14.1 {Slide 1 title}", " 14.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-3.html", "14.2 Meeting Videos", " 14.2 Meeting Videos 14.2.1 Cohort 1 Meeting chat log "],["placeholder-3.html", "Chapter 15 PLACEHOLDER", " Chapter 15 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-4.html", "15.1 {Slide 1 title}", " 15.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-4.html", "15.2 Meeting Videos", " 15.2 Meeting Videos 15.2.1 Cohort 1 Meeting chat log "],["placeholder-4.html", "Chapter 16 PLACEHOLDER", " Chapter 16 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-5.html", "16.1 {Slide 1 title}", " 16.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-5.html", "16.2 Meeting Videos", " 16.2 Meeting Videos 16.2.1 Cohort 1 Meeting chat log "],["placeholder-5.html", "Chapter 17 PLACEHOLDER", " Chapter 17 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-6.html", "17.1 {Slide 1 title}", " 17.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-6.html", "17.2 Meeting Videos", " 17.2 Meeting Videos 17.2.1 Cohort 1 Meeting chat log "],["placeholder-6.html", "Chapter 18 PLACEHOLDER", " Chapter 18 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-7.html", "18.1 {Slide 1 title}", " 18.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-7.html", "18.2 Meeting Videos", " 18.2 Meeting Videos 18.2.1 Cohort 1 Meeting chat log "],["placeholder-7.html", "Chapter 19 PLACEHOLDER", " Chapter 19 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-8.html", "19.1 {Slide 1 title}", " 19.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-8.html", "19.2 Meeting Videos", " 19.2 Meeting Videos 19.2.1 Cohort 1 Meeting chat log "],["placeholder-8.html", "Chapter 20 PLACEHOLDER", " Chapter 20 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-9.html", "20.1 {Slide 1 title}", " 20.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-9.html", "20.2 Meeting Videos", " 20.2 Meeting Videos 20.2.1 Cohort 1 Meeting chat log "],["placeholder-9.html", "Chapter 21 PLACEHOLDER", " Chapter 21 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-10.html", "21.1 {Slide 1 title}", " 21.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-10.html", "21.2 Meeting Videos", " 21.2 Meeting Videos 21.2.1 Cohort 1 Meeting chat log "],["placeholder-10.html", "Chapter 22 PLACEHOLDER", " Chapter 22 PLACEHOLDER Learning objectives: {These are nice to have, but take some extra work. It’s ok to skip these if necessary.} "],["slide-1-title-11.html", "22.1 {Slide 1 title}", " 22.1 {Slide 1 title} {Create slides as sections marked with ##, but keep them short like a slide.} "],["meeting-videos-11.html", "22.2 Meeting Videos", " 22.2 Meeting Videos 22.2.1 Cohort 1 Meeting chat log "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
